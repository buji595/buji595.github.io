<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F28%2Fsaltstack%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[安装完Saltstack后可以立即执行shell命令，更新软件包并将文件同时分不到所有受管系统。所有回复都以一致的可配置格式返回。远程执行参考文档：http://docs.saltstack.cn/topics/tutorials/modules.html1234567[root@salt-master ~]# salt '*' cmd.run "uptime"salt-minion01: 15:23:08 up 1 day, 58 min, 2 users, load average: 0.00, 0.03, 0.08salt-minion02: 15:23:08 up 21:38, 2 users, load average: 0.00, 0.04, 0.10salt-minion03: 15:23:08 up 21:36, 2 users, load average: 0.00, 0.04, 0.10 Salt命令的结构语法1salt '&lt;target&gt;' &lt;function&gt; [arguments] 目标主机Target1、通配符匹配123456[root@salt-master ~]# salt '*' test.ping[root@salt-master ~]# salt 'salt-minion01' test.ping[root@salt-master ~]# salt '*01' test.ping[root@salt-master ~]# salt 'salt-minion0[1|2]' test.ping[root@salt-master ~]# salt 'salt-minion0[!1|2]' test.ping[root@salt-master ~]# salt 'salt-minion0?' test.ping 2、列表匹配1[root@salt-master ~]# salt -L 'salt-minion01,salt-minion02' test.ping 3、正则匹配12[root@salt-master ~]# salt -E '^salt' test.ping[root@salt-master ~]# salt -E '^salt.*2$' test.ping 4、IP匹配12[root@salt-master ~]# salt -S '192.168.1.32' test.ping[root@salt-master ~]# salt -S '192.168.1.0/24' test.ping 5、复合匹配1[root@salt-master ~]# salt -C 'G@os:CentOS and S@192.168.1.32' test.ping 6、分组匹配1234567[root@salt-master ~]# vim /etc/salt/masternodegroups: webserver: 'salt-minion01,salt-minion02' dbserver: 'salt-minion03[root@salt-master ~]# systemctl restart salt-master[root@salt-master ~]# salt -N 'webserver' test.ping[root@salt-master ~]# salt -N 'dbserver' test.ping 7、Grains匹配12[root@salt-master ~]# salt -G 'os:CentOS' test.ping[root@salt-master ~]# salt -G 'localhost:salt-minion02' test.ping 说明：上面这些匹配方式在top.sls文件中同样适用。 模块Module test模块多用于测试user模块用于用户管理cmd模块可以执行任意shell命令pkg模块用于软件包管理file模块多用于配置service模块用于服务管理 所有模块列表 test模块123模块名：test功能：用于测试[root@salt-master ~]# salt '*' test.ping user模块123参考：http://docs.saltstack.cn/ref/modules/all/salt.modules.useradd.html#module-salt.modules.useradd# salt '*' user.add name &lt;uid&gt; &lt;gid&gt; &lt;groups&gt; &lt;home&gt; &lt;shell&gt;[root@salt-master ~]# salt '*' user.add testuser cmd模块12345模块名：cmd功能：实现远程的命令行调用执行（默认具备root操作权限，使用时需评估风险）#查看所有minion内存和磁盘使用情况[root@salt-master ~]# salt '*' cmd.run "free -m"[root@salt-master ~]# salt '*' cmd.run "df -h" pkg模块1234567891011121314模块名：pkg功能：软件包状态管理，会根据操作系统不同，选择对应的安装方式（如CentOS系统默认使用yum，Debian系统默认使用apt-get）#安装[root@salt-master ~]# salt '*' pkg.install "vsftpd" #卸载[root@salt-master ~]# salt '*' pkg.remove "vsftpd"#安装最新版本[root@salt-master ~]# salt '*' pkg.latest_version "vsftpd"#更新软件包[root@salt-master ~]# salt '*' pkg.upgrade "vsftpd"#查看帮助手册[root@salt-master ~]# salt '*' pkg file模块1234567891011121314151617181920212223242526272829模块名：file功能：被控主机常见的文件操作，包括文件读写、权限、查找、校验#校验所有minion主机文件的加密信息，支持md5、sha1、sha224、shs256、sha384、sha512加密算法[root@salt-master ~]# salt '*' file.get_sum /etc/passwd md5#修改所有minion主机/etc/passwd文件的属组、用户权限、等价于chown root:root /etc/passwd[root@salt-master ~]# salt '*' file.chown /etc/passwd root root#获取所有minion主机/etc/passwd的stats信息[root@salt-master ~]# salt '*' file.stats /etc/passwd#获取所有minion主机/etc/passwd的权限mode,如755,644[root@salt-master ~]# salt '*' file.get_mode /etc/passwd#修改所有minion主机/etc/passwd的权限mode为0644[root@salt-master ~]# salt '*' file.set_mode /etc/passwd 0644#在所有minion主机创建/opt/test目录[root@salt-master ~]# salt '*' file.mkdir /opt/test#在所有minion主机穿件/tmp/test.conf文件[root@salt-master ~]# salt '*' file.touch /tmp/test.conf#将所有minion主机/tmp/test.conf文件追加内容'maxclient 100'[root@salt-master ~]# salt '*' file.append /tmp/test.conf 'maxclient 100'#删除所有minion主机的/tmp/test.conf文件[root@salt-master ~]# salt '*' file.remove /tmp/test.conf service模块12345678910111213模块名：service功能：被控主机程序包服务管理#开启（enable）禁用（disable）salt '*' service.enable &lt;service name&gt;salt '*' service.disabled &lt;service name&gt;#reload、restart、start、stop、status操作salt '*' service.reload &lt;service name&gt;salt '*' service.restart &lt;service name&gt;salt '*' service.start &lt;service name&gt;salt '*' service.stop &lt;service name&gt;salt '*' service.status &lt;service name&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ansible Module]]></title>
    <url>%2F2019%2F05%2F27%2FAnsible%20Ad-hoc%E5%B8%B8%E7%94%A8Module%2F</url>
    <content type="text"><![CDATA[Ansible Ad-hoc模式常用模块ansible-doc 常用命令1234567891011# ansible-doc -hUsage: ansible-doc [-l|-F|-s] [options] [-t &lt;plugin type&gt; ] [plugin]-j 以json格式显示所有模块信息-l 列出所有的模块-s 查看模块常用参数# 直接跟模块名，显示模块所有信息[root@ansible ~]# ansible-doc -j[root@ansible ~]# ansible-doc -l[root@ansible ~]# ansible-doc -l |wc -l #统计所有模块个数，ansible2.8共计2834个模块2834 命令相关的模块command ansible默认的模块,执行命令，注意：shell中的&quot;&lt;&quot;, &quot;&gt;&quot;, &quot;|&quot;, &quot;;&quot;, &quot;&amp;&quot;,&quot;$&quot;等特殊字符不能在command模块中使用，如果需要使用，则用shell模块 1234567891011121314151617181920212223242526# 查看模块参数[root@ansible ~]# ansible-doc -s command# 在192.168.1.31服务器上面执行ls命令，默认是在当前用户的家目录/root[root@ansible ~]# ansible 192.168.1.31 -a 'ls'# chdir 先切换工作目录，再执行后面的命令，一般情况下在编译时候使用[root@ansible ~]# ansible 192.168.1.31 -a 'chdir=/tmp pwd'192.168.1.31 | CHANGED | rc=0 &gt;&gt;/tmp# creates 如果creates的文件存在，则执行后面的操作[root@ansible ~]# ansible 192.168.1.31 -a 'creates=/tmp ls /etc/passwd' #tmp目录存在，则不执行后面的ls命令192.168.1.31 | SUCCESS | rc=0 &gt;&gt;skipped, since /tmp exists[root@ansible ~]# ansible 192.168.1.31 -a 'creates=/tmp11 ls /etc/passwd' # tmp11文件不存在，则执行后面的ls命令192.168.1.31 | CHANGED | rc=0 &gt;&gt;/etc/passwd# removes 和creates相反，如果removes的文件存在，才执行后面的操作[root@ansible ~]# ansible 192.168.1.31 -a 'removes=/tmp ls /etc/passwd' #tmp文件存在，则执行了后面的ls命令192.168.1.31 | CHANGED | rc=0 &gt;&gt;/etc/passwd[root@ansible ~]# ansible 192.168.1.31 -a 'removes=/tmp11 ls /etc/passwd' #tmp11文件不存在，则没有执行后面的ls命令192.168.1.31 | SUCCESS | rc=0 &gt;&gt;skipped, since /tmp11 does not exist shell 专门用来执行shell命令的模块，和command模块一样，参数基本一样，都有chdir,creates,removes等参数 123456789101112131415# 查看模块参数[root@ansible ~]# ansible-doc -s shell[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'mkdir /tmp/test'[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'ls /tmp' #执行下面这条命令，每次执行都会更新文件的时间戳[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'cd /tmp/test &amp;&amp; touch 1.txt &amp;&amp; ls' 192.168.1.31 | CHANGED | rc=0 &gt;&gt;1.txt# 由于有时候不想更新文件的创建时间戳，则如果存在就不执行creates[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'creates=/tmp/test/1.txt cd /tmp/test &amp;&amp; touch 1.txt &amp;&amp; ls'192.168.1.31 | SUCCESS | rc=0 &gt;&gt;skipped, since /tmp/test/1.txt exists script 用于在被管理机器上面执行shell脚本的模块，脚本无需在被管理机器上面存在 1234567891011121314151617181920212223# 查看模块参数[root@ansible ~]# ansible-doc -s script# 编写shell脚本[root@ansible ~]# vim ansible_test.sh #!/bin/bashecho `hostname`# 在所有被管理机器上执行该脚本[root@ansible ~]# ansible all -m script -a '/root/ansible_test.sh'192.168.1.32 | CHANGED =&gt; &#123; "changed": true, "rc": 0, "stderr": "Shared connection to 192.168.1.32 closed.\r\n", "stderr_lines": [ "Shared connection to 192.168.1.32 closed." ], "stdout": "linux.node02.com\r\n", "stdout_lines": [ "linux.node02.com" ]&#125;...... 文件相关的模块file 用于对文件的处理，创建，删除，权限控制等 1234567891011121314151617181920212223242526272829# 查看模块参数[root@ansible ~]# ansible-doc -s filepath #要管理的文件路径recurse #递归state： directory #创建目录，如果目标不存在则创建目录及其子目录 touch #创建文件，如果文件存在，则修改文件 属性 absent #删除文件或目录 mode #设置文件或目录权限 owner #设置文件或目录属主信息 group #设置文件或目录属组信息 link #创建软连接，需要和src配合使用 hard #创建硬连接，需要和src配合使用# 创建目录[root@ansible ~]# ansible 192.168.1.31 -m file -a 'path=/tmp/test1 state=directory'# 创建文件[root@ansible ~]# ansible 192.168.1.31 -m file -a 'path=/tmp/test2 state=touch'# 建立软链接（src表示源文件，path表示目标文件）[root@ansible ~]# ansible 192.168.1.31 -m file -a 'src=/tmp/test1 path=/tmp/test3 state=link'# 删除文件[root@ansible ~]# ansible 192.168.1.31 -m file -a 'path=/tmp/test2 state=absent'# 创建文件时同时设置权限等信息[root@ansible ~]# ansible 192.168.1.31 -m file -a 'path=/tmp/test4 state=directory mode=775 owner=root group=root' copy 用于管理端复制文件到远程主机，并可以设置权限，属组，属主等12345678910111213141516171819202122# 查看模块参数[root@ansible ~]# ansible-doc -s copysrc #需要copy的文件的源路径dest #需要copy的文件的目标路径backup #对copy的文件进行备份content #直接在远程主机被管理文件中添加内容，会覆盖原文件内容mode #对copy到远端的文件设置权限owner #对copy到远端的文件设置属主group #对copy到远端文件设置属组# 复制文件到远程主机并改名[root@ansible ~]# ansible 192.168.1.31 -m copy -a 'dest=/tmp/a.sh src=/root/ansible_test.sh'# 复制文件到远程主机，并备份远程文件,安装时间信息备份文件（当更新文件内容后，重新copy时用到）[root@ansible ~]# ansible 192.168.1.31 -m copy -a 'dest=/tmp/a.sh src=/root/ansible_test.sh backup=yes'# 直接在远程主机a.sh中添加内容[root@ansible ~]# ansible 192.168.1.31 -m copy -a 'dest=/tmp/a.sh content="#!/bin/bash\n echo `uptime`"'# 复制文件到远程主机，并设置权限及属主与属组[root@ansible ~]# ansible 192.168.1.31 -m copy -a 'dest=/tmp/passwd src=/etc/passwd mode=700 owner=root group=root' fetch 用于从被管理机器上面拉取文件，拉取下来的内容会保留目录结构，一般情况用在收集被管理机器的日志文件等123456789101112131415# 查看模块参数[root@ansible ~]# ansible-doc -s fetchsrc #指定需要从远端机器拉取的文件路径dest #指定从远端机器拉取下来的文件存放路径# 从被管理机器上拉取cron日志文件，默认会已管理节点地址创建一个目录，并存放在内[root@ansible ~]# ansible 192.168.1.31 -m fetch -a 'dest=/tmp src=/var/log/cron'[root@ansible ~]# tree /tmp/192.168.1.31//tmp/192.168.1.31/└── var └── log └── cron2 directories, 1 file 用户相关的模块user 用于对系统用户的管理，用户的创建、删除、家目录、属组等设置1234567891011121314151617181920212223242526272829303132333435# 查看模块参数[root@ansible ~]# ansible-doc -s username #指定用户的名字home #指定用户的家目录uid #指定用户的uidgroup #指定用户的用户组groups #指定用户的附加组password #指定用户的密码shell #指定用户的登录shellcreate_home #是否创建用户家目录，默认是yesremove #删除用户时，指定是否删除家目录state： absent #删除用户 # 创建用户名指定家目录，指定uid及组[root@ansible ~]# ansible 192.168.1.31 -m user -a 'name=mysql home=/opt/mysql uid=1002 group=root'[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'id mysql &amp;&amp; ls -l /opt'192.168.1.31 | CHANGED | rc=0 &gt;&gt;uid=1002(mysql) gid=0(root) 组=0(root)总用量 0drwx------ 3 mysql root 78 5月 27 18:13 mysql# 创建用户，不创建家目录，并且不能登录[root@ansible ~]# ansible 192.168.1.31 -m user -a 'name=apache shell=/bin/nologin uid=1003 create_home=no'[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'id apache &amp;&amp; tail -1 /etc/passwd'192.168.1.31 | CHANGED | rc=0 &gt;&gt;uid=1003(apache) gid=1003(apache) 组=1003(apache)apache:x:1003:1003::/home/apache:/bin/nologin# 删除用户[root@ansible ~]# ansible 192.168.1.31 -m user -a 'name=apache state=absent'# 删除用户并删除家目录[root@ansible ~]# ansible 192.168.1.31 -m user -a 'name=mysql state=absent remove=yes' group 用于创建组，当创建用户时如果需要指定组，组不存在的话就可以通过group先创建组12345678910111213141516# 查看模块参数[root@ansible ~]# ansible-doc -s groupname #指定组的名字gid #指定组的gidstate： absent #删除组 present #创建组（默认的状态）# 创建组[root@ansible ~]# ansible 192.168.1.31 -m group -a 'name=www'# 创建组并指定gid[root@ansible ~]# ansible 192.168.1.31 -m group -a 'name=www1 gid=1005'# 删除组[root@ansible ~]# ansible 192.168.1.31 -m group -a 'name=www1 state=absent' 软件包相关的模块yum 用于对软件包的管理，下载、安装、卸载、升级等操作12345678910111213141516171819202122232425262728293031323334# 查看模块参数[root@ansible ~]# ansible-doc -s yumname #指定要操作的软件包名字download_dir #指定下载软件包的存放路径，需要配合download_only一起使用download_only #只下载软件包，而不进行安装，和yum --downloadonly一样list: installed #列出所有已安装的软件包 updates #列出所有可以更新的软件包 repos #列出所有的yum仓库state: installed, present #安装软件包(两者任选其一都可以) removed, absent #卸载软件包 latest #安装最新软件包 # 列出所有已安装的软件包[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'list=installed'# 列出所有可更新的软件包[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'list=updates'#列出所有的yum仓库[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'list=repos'#只下载软件包并到指定目录下[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'name=httpd download_only=yes download_dir=/tmp'#安装软件包[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'name=httpd state=installed'#卸载软件包[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'name=httpd state=removed'#安装包组，类似yum groupinstall 'Development Tools'[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'name="@Development Tools" state=installed' pip 用于安装python中的包12345678# 查看模块参数[root@ansible ~]# ansible-doc -s pip# 使用pip时，需要保证被管理机器上有python-pip软件包[root@ansible ~]# ansible 192.168.1.31 -m yum -a 'name=python-pip'# 安装pip包[root@ansible ~]# ansible 192.168.1.31 -m pip -a 'name=flask' service 服务模块，用于对服务进行管理，服务的启动、关闭、开机自启等123456789101112# 查看模块参数[root@ansible ~]# ansible-doc -s servicename #指定需要管理的服务名enabled #指定是否开机自启动state: #指定服务状态 started #启动服务 stopped #停止服务 restarted #重启服务 reloaded #重载服务# 启动服务，并设置开机自启动 [root@ansible ~]# ansible 192.168.1.31 -m service -a 'name=crond state=started enabled=yes' 计划任务相关的模块cron 用于指定计划任务，和crontab -e一样12345678910111213141516171819202122232425# 查看模块参数[root@ansible ~]# ansible-doc -s cronjob #指定需要执行的任务minute #分钟hour #小时day #天month #月weekday #周name #对计划任务进行描述state: absetn #删除计划任务# 创建一个计划任务，并描述是干嘛用的[root@ansible ~]# ansible 192.168.1.31 -m cron -a "name='这是一个测试的计划任务' minute=* hour=* day=* month=* weekday=* job='/bin/bash /root/test.sh'"[root@ansible ~]# ansible 192.168.1.31 -m shell -a 'crontab -l'192.168.1.31 | CHANGED | rc=0 &gt;&gt;#Ansible: 这是一个测试的计划任务* * * * * /bin/bash /root/test.sh# 创建一个没有带描述的计划任务[root@ansible ~]# ansible 192.168.1.31 -m cron -a "job='/bin/sh /root/test.sh'"# 删除计划任务[root@ansible ~]# ansible 192.168.1.31 -m cron -a "name='None' job='/bin/sh /root/test.sh' state=absent" 系统信息相关的模块setup 用于获取系统信息的一个模块12345678910111213141516171819202122232425# 查看模块参数[root@ansible ~]# ansible-doc -s setup# 查看系统所有信息[root@ansible ~]# ansible 192.168.1.31 -m setup# filter 对系统信息进行过滤[root@ansible ~]# ansible 192.168.1.31 -m setup -a 'filter=ansible_all_ipv4_addresses'# 常用的过滤选项ansible_all_ipv4_addresses 所有的ipv4地址ansible_all_ipv6_addresses 所有的ipv6地址ansible_architecture 系统的架构ansible_date_time 系统时间ansible_default_ipv4 系统的默认ipv4地址ansible_distribution 系统名称ansible_distribution_file_variety 系统的家族ansible_distribution_major_version 系统的版本ansible_domain 系统所在的域ansible_fqdn 系统的主机名ansible_hostname 系统的主机名,简写ansible_os_family 系统的家族ansible_processor_cores cpu的核数ansible_processor_count cpu的颗数ansible_processor_vcpus cpu的个数]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible快速入门]]></title>
    <url>%2F2019%2F05%2F26%2FAnsible%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[介绍 Ansible是一款简单的运维自动化工具，只需要使用ssh协议连接就可以来进行系统管理，自动化执行命令，部署等任务。 Ansible的特点 1、ansible不需要单独安装客户端，也不需要启动任何服务2、ansible是python中的一套完整的自动化执行任务模块3、ansible playbook 采用yaml配置，对于自动化任务执行过一目了然 Ansible组成结构 Ansible是Ansible的命令工具，核心执行工具；一次性或临时执行的操作都是通过该命令执行。 Ansible Playbook任务剧本（又称任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，yaml格式。 InventoryAnsible管理主机的清单，默认是/etc/ansible/hosts文件。 ModulesAnsible执行命令的功能模块，Ansible2.3版本为止，共有1039个模块。还可以自定义模块。 Plugins插件，模块功能的补充，常有连接类型插件，循环插件，变量插件，过滤插件，插件功能用的较少。 API提供给第三方程序调用的应用程序编程接口。 环境准备 IP 系统 主机名 描述 192.168.1.30 CentOS7 ansible ansible管理节点 192.168.1.31 CentOS7 linux.node01.com 被管理节点1 192.168.1.32 CentOS7 linux.node02.com 被管理节点2 192.168.1.33 CentOS7 linux.node03.com 被管理节点3 192.168.1.36 CentOS6 linux.node06.com 被管理节点6 Ansible安装1）配置epel源123[root@ansible ~]# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo[root@ansible ~]# yum clean all[root@ansible ~]# yum makecache 2）安装ansible12345678910[root@ansible ~]# yum -y install ansible# 查看ansible版本[root@ansible ~]# ansible --versionansible 2.8.0 config file = /etc/ansible/ansible.cfg configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible python version = 2.7.5 (default, Aug 4 2017, 00:39:18) [GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] Ansible Inventory文件Inventory中文文档 Inventory文件通常用于定义要管理的主机的认证信息，例如ssh登录用户名、密码以及key相关信息。可以同时操作一个组的多台主机，组与主机组之间的关系都是通过inventory文件配置。配置文件路径为：/etc/ansible/hosts 基于密码连接12345678910111213141516171819[root@ansible ~]# vim /etc/ansible/hosts# 方法一 主机+端口+密码[webserver]192.168.1.31 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass="123456"192.168.1.32 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass="123456"192.168.1.33 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass="123456"192.168.1.36 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass="123456"# 方法二 主机+端口+密码[webserver]192.168.1.3[1:3] ansible_ssh_user=root ansible_ssh_pass="123456"# 方法二 主机+端口+密码[webserver]192.168.1.3[1:3][webserver:vars]ansible_ssh_pass="123456" 基于秘钥连接 基于秘钥连接需要先创建公钥和私钥，并发送给被管理机器 1）生成公私钥12[root@ansible ~]# ssh-keygen[root@ansible ~]# for i in &#123;1,2,3,6&#125;; do ssh-copy-id -i 192.168.1.3$i ; done 2）配置连接1234567891011121314[root@ansible ~]# vim /etc/ansible/hosts# 方法一 主机+端口+密钥[webserver]192.168.1.31:22192.168.1.32192.168.1.33192.168.1.36# 方法一 别名主机+端口+密钥[webserver]node1 ansible_ssh_host=192.168.1.31 ansible_ssh_port=22node2 ansible_ssh_host=192.168.1.32 ansible_ssh_port=22node3 ansible_ssh_host=192.168.1.33 ansible_ssh_port=22node6 ansible_ssh_host=192.168.1.36 ansible_ssh_port=22 主机组的使用123456789101112131415# 主机组变量名+主机+密码[apache]192.168.1.36192.168.1.33[apache.vars]ansible_ssh_pass='123456'# 主机组变量名+主机+密钥[nginx]192.168.1.3[1:2]# 定义多个组，把一个组当另外一个组的组员[webserver:children] #webserver组包括两个子组：apache nginxapachenginx 临时指定inventory1）先编辑一个主机定义清单12345[root@ansible ~]# vim /etc/dockers[dockers]192.168.1.31 ansible_ssh_pass='123456'192.168.1.32192.168.1.33 2）在执行命令是指定inventory1234[root@ansible ~]# ansible dockers -m ping -i /etc/dockers -o 192.168.1.33 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;192.168.1.32 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;192.168.1.31 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125; Inventory内置参数 Ansible Ad-HocAd-Hoc中文文档 ad hoc —— 临时的，在ansible中是指需要快速执行，并且不需要保存的命令。说白了就是执行简单的命令——一条命令。对于复杂的命令则为playbook，类似于saltstack的state sls状态文件。 ansible命令格式1）常用命令参数12345678[root@ansible ~]# ansible -hUsage: ansible &lt;host-pattern&gt; [options]-a MODULE_ARGS #模块参数-C, --check #检查语法-f FORKS #并发--list-hosts #列出主机列表-m MODULE_NAME #模块名字-o 使用精简的输出 2）示例12345[root@ansible ~]# ansible webserver -m shell -a 'uptime' -o192.168.1.36 | CHANGED | rc=0 | (stdout) 13:46:14 up 1 day, 9:20, 4 users, load average: 0.00, 0.00, 0.00192.168.1.33 | CHANGED | rc=0 | (stdout) 21:26:33 up 1 day, 8:51, 3 users, load average: 0.00, 0.01, 0.05192.168.1.31 | CHANGED | rc=0 | (stdout) 21:26:33 up 1 day, 8:50, 3 users, load average: 0.00, 0.01, 0.05192.168.1.32 | CHANGED | rc=0 | (stdout) 21:26:33 up 1 day, 8:59, 3 users, load average: 0.00, 0.01, 0.05 3）命令说明 host-pattern格式目标target主机，主机组匹配方式 主机的匹配12345678# 一台目标主机[root@ansible ~]# ansible 192.168.1.31 -m ping# 多台目标主机[root@ansible ~]# ansible 192.168.1.31,192.168.1.32 -m ping# 所有目标主机[root@ansible ~]# ansible all -m ping 组的匹配1234567891011121314151617181920212223242526272829# 组的配置信息如下：这里定义了一个nginx组和一个apache组[root@ansible ~]# ansible nginx --list hosts (2): 192.168.1.31 192.168.1.32[root@ansible ~]# ansible apache --list hosts (3): 192.168.1.36 192.168.1.33 192.168.1.32# 一个组的所有主机匹配[root@ansible ~]# ansible apache -m ping# 匹配apache组中有，但是nginx组中没有的所有主机[root@ansible ~]# ansible 'apache:!nginx' -m ping -o192.168.1.36 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;192.168.1.33 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;# 匹配apache组和nginx组中都有的机器（并集）[root@ansible ~]# ansible 'apache:&amp;nginx' -m ping -o192.168.1.32 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;# 匹配apache组nginx组两个组所有的机器（并集）；等于ansible apache,nginx -m ping[root@ansible ~]# ansible 'apache:nginx' -m ping -o192.168.1.32 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;192.168.1.31 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;192.168.1.33 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;192.168.1.36 | SUCCESS =&gt; &#123;"ansible_facts": &#123;"discovered_interpreter_python": "/usr/bin/python"&#125;, "changed": false, "ping": "pong"&#125;]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux保存history到日志文件]]></title>
    <url>%2F2019%2F05%2F22%2Flinux%E4%BF%9D%E5%AD%98history%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在linux下面，为了保证服务器安全，通常会记录所敲命令的历史记录，但是记录为1000条，并且退出重新登录后，之前的变会没有了，通过编辑/etc/bashrc文件记录历史命令到日志文件下面，并已登录来源IP，登录用户名，登录时间命名日志文件名字 查看默认的history 编辑/etc/bashrc编辑/etc/bashrc文件，加入以下内容，也可以放在/etc/profile文件里123456789101112131415161718192021222324252627# vim /etc/bashrcUSER_IP=$(echo -e "\033[31m\033[1m`who -u am i 2&gt;/dev/null| awk '&#123;print $NF&#125;'|sed -e 's/[()]//g'`\033[0m")IP=$(who -u am i 2&gt;/dev/null| awk '&#123;print $NF&#125;'|sed -e 's/[()]//g')USER=$(whoami)USER_NAME=`echo -e "\033[36m\033[1m$(whoami) \033[0m"`HISTFILESIZE=100000HISTSIZE=4096HISTTIMEFORMAT="%F %T $USER_IP $USER_NAME "if [ "$USER_IP" = "" ]then USER_IP=`hostname`fiif [ ! -d /var/log/history ]then mkdir /var/log/history chmod 777 /var/log/historyfiif [ ! -d /var/log/history/$&#123;LOGNAME&#125; ]then mkdir /var/log/history/$&#123;LOGNAME&#125; chmod 300 /var/log/history/$&#123;LOGNAME&#125;fiDT=`date "+%Y%m%d_%H%M"`export HISTFILE="/var/log/history/$&#123;LOGNAME&#125;/$&#123;DT&#125;_$&#123;USER&#125;_$&#123;IP&#125;"chmod 600 /var/log/history/$&#123;LOGNAME&#125;/* 2&gt;/dev/null 退出重新登录再次查看查看前面保留的历史记录日志12345678910111213141516171819[root@salt-master ~]# ll /var/log/history/总用量 0d-wx------. 2 root root 6 5月 22 14:27 root[root@salt-master ~]# ll /var/log/history/root/总用量 4-rw-------. 1 root root 123 5月 22 14:29 20190522_1427_root_192.168.1.123[root@salt-master ~]# cat /var/log/history/root/20190522_1427_root_192.168.1.123 #1558506461ls#1558506467history#1558506519ll /var/log/history/#1558506571ll /var/log/history/root/#1558506574exit]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack项目实战]]></title>
    <url>%2F2019%2F05%2F21%2Fsaltstack%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[项目架构规划 后端web服务器使用Nginx+Php作为站点，通过HAproxy做负载均衡，Keepalived做高可用 项目环境准备 说明： 关闭防火墙、selinux、时间同步等host绑定12345678910[root@salt-master ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.1.30 salt-master192.168.1.31 salt-minion01192.168.1.32 salt-minion02192.168.1.33 salt-minion03192.168.1.34 salt-minion04[root@salt-master ~]# for i in `seq 4`; do scp /etc/hosts 192.168.1.3$i:/etc/hosts ; done 软件安装参考地址1）Master上软件安装12345[root@salt-master ~]# yum -y install https://mirrors.aliyun.com/saltstack/yum/redhat/salt-repo-latest-2.el7.noarch.rpm[root@salt-master ~]# sed -i "s/repo.saltstack.com/mirrors.aliyun.com\/saltstack/g" /etc/yum.repos.d/salt-latest.repo[root@salt-master ~]# yum -y install salt-master[root@salt-master ~]# systemctl enable salt-master[root@salt-master ~]# systemctl start salt-master 2）Minion上软件安装并配置123456# yum -y install https://mirrors.aliyun.com/saltstack/yum/redhat/salt-repo-latest-2.el7.noarch.rpm# yum -y install salt-minion# cp /etc/salt/minion&#123;,.back&#125;# sed -i '/#master: /c\master: salt-master' /etc/salt/minion# systemctl enable salt-minion# systemctl start salt-minion Master上认证1234567891011121314151617181920212223242526272829303132333435363738394041[root@salt-master ~]# systemctl restart salt-master[root@salt-master ~]# salt-key -L Accepted Keys:Denied Keys:Unaccepted Keys:salt-minion01salt-minion02salt-minion03salt-minion04Rejected Keys:[root@salt-master ~]# salt-key -A -yThe following keys are going to be accepted:Unaccepted Keys:salt-minion01salt-minion02salt-minion03salt-minion04Key for minion salt-minion01 accepted.Key for minion salt-minion02 accepted.Key for minion salt-minion03 accepted.Key for minion salt-minion04 accepted.[root@salt-master ~]# salt-key -L Accepted Keys:salt-minion01salt-minion02salt-minion03salt-minion04Denied Keys:Unaccepted Keys:Rejected Keys:[root@salt-master ~]# salt '*' test.pingsalt-minion01: Truesalt-minion02: Truesalt-minion03: Truesalt-minion04: True Master上state编写state环境设置 说明：该案例在prod环境下配置，在prod下面创建了一个modules的目录，所有的安装配置都放在这个目录下面了，里面分别又对应创建了对应的软件目录，每个软件目录下面的files目录用来存放的是软件包或者配置文件模板1234567891011121314151617181920212223242526272829303132[root@salt-master ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt/base test: - /srv/salt/test prod: - /srv/salt/prod dev: - /srv/salt/dev[root@salt-master ~]# systemctl restart salt-master[root@salt-master ~]# mkdir -p /srv/salt/&#123;base,test,prod,dev&#125;[root@salt-master ~]# mkdir -p /srv/salt/prod/modules/&#123;nginx,php,mysql,haproxy,keepalived,lnmp&#125;/files[root@salt-master ~]# mkdir /srv/salt/prod/modules/user[root@salt-master ~]# tree /srv/salt/prod/modules//srv/salt/prod/modules/├── haproxy│ └── files├── keepalived│ └── files├── lnmp│ └── files├── mysql│ └── files├── nginx│ └── files├── php│ └── files└── user13 directories, 0 files sls文件编写pkg基础包安装源码编译所需要用到的基础软件包1234567891011121314151617181920212223242526272829303132333435363738[root@salt-master ~]# cat /srv/salt/prod/modules/pkg.sls pkg-install: pkg.installed: - pkgs: - gcc - gcc-c++ - make - autoconf - glibc - glibc-devel - glib2 - glib2-devel - pcre - pcre-devel - zlib - zlib-devel - openssl - openssl-devel - libpng - libpng-devel - freetype - freetype-devel - libxml2 - libxml2-devel - bzip2 - bzip2-devel - ncurses - curl - gdbm-devel - libXpm-devel - libX11-devel - gd-devel - gmp-devel - readline-devel - libxslt-devel - expat-devel - xmlrpc-c - xmlrpc-c-devel useradd创建网站运行用户12345678910111213[root@salt-master ~]# cat /srv/salt/prod/modules/user/www.sls www-user-group: group.present: - name: www - gid: 2000 user.present: - name: www - fullname: www - shell: /sbin/nologin - uid: 2000 - gid: 2000 - unless: id www nginx1）软件包准备，及配置文件模板，启动文件模板123456789101112[root@salt-master ~]# cd /srv/salt/prod/modules/nginx/[root@salt-master nginx]# tree .├── files│ ├── nginx-1.12.2.tar.gz│ ├── nginx-1.16.0.tar.gz│ ├── nginx.conf.template│ └── nginx.service.template├── install.sls└── service.sls1 directory, 6 files 2）install.sls1234567891011121314151617181920[root@salt-master nginx]# cat install.sls &#123;% set nginx_version = "1.16.0"%&#125;include: - modules.pkg - modules.user.wwwnginx-install: file.managed: - name: /usr/local/src/nginx-&#123;&#123; nginx_version &#125;&#125;.tar.gz - source: salt://modules/nginx/files/nginx-&#123;&#123; nginx_version &#125;&#125;.tar.gz - user: root - group: root - mode: 644 cmd.run: - name: cd /usr/local/src/ &amp;&amp; tar xf nginx-&#123;&#123; nginx_version &#125;&#125;.tar.gz &amp;&amp; cd nginx-&#123;&#123; nginx_version &#125;&#125; &amp;&amp; ./configure --prefix=/usr/local/nginx-&#123;&#123; nginx_version &#125;&#125; --user=root --group=root --with-http_ssl_module --with-stream --with-http_stub_status_module --with-file-aio --with-http_gzip_static_module &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -s /usr/local/nginx-&#123;&#123; nginx_version &#125;&#125; /usr/local/nginx - unless: test -d /usr/local/nginx-&#123;&#123; nginx_version &#125;&#125; &amp;&amp; test -L /usr/local/nginx - require: - file: nginx-install - pkg: pkg-install 3）service.sls123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@salt-master nginx]# cat service.sls #引入nginx安装slsinclude: - modules.nginx.install#添加systemctlnginx-init: file.managed: - name: /usr/lib/systemd/system/nginx.service - source: salt://modules/nginx/files/nginx.service.template - user: root - group: root - mode: 755 - unless: test -f /usr/lib/systemd/system/nginx.service cmd.run: - name: systemctl daemon-reload - require: - file: nginx-init#配置文件/usr/local/nginx/conf/nginx.conf: file.managed: - source: salt://modules/nginx/files/nginx.conf.template - user: root - group: root - mode: 644#启动nginxnginx-service: file.directory: - name: /usr/local/nginx/conf/conf.d - user: root - group: root - mode: 755 - require: - cmd: nginx-install service.running: - name: nginx - enable: True - reload: True - require: - cmd: nginx-init - watch: - file: /usr/local/nginx/conf/nginx.conf - file: nginx-service php1）软件包准备，及配置文件模板，启动文件模板12345678910111213[root@salt-master ~]# cd /srv/salt/prod/modules/php/[root@salt-master php]# tree.├── files│ ├── php-5.6.40.tar.gz│ ├── php-fpm.conf.template│ ├── php-fpm.service.template│ ├── php-fpm.template│ └── php.ini.template├── install.sls└── service.sls1 directory, 7 files 2）install.sls12345678910111213141516171819[root@salt-master php]# cat install.sls &#123;% set php_version = "5.6.40" %&#125;include: - modules.pkgphp-install: file.managed: - name: /usr/local/src/php-&#123;&#123; php_version &#125;&#125;.tar.gz - source: salt://modules/php/files/php-&#123;&#123; php_version &#125;&#125;.tar.gz - user: root - group: root - mode: 644 cmd.run: - name: cd /usr/local/src/ &amp;&amp; tar xf php-&#123;&#123; php_version &#125;&#125;.tar.gz &amp;&amp; cd php-&#123;&#123; php_version &#125;&#125; &amp;&amp; ./configure --prefix=/usr/local/php-&#123;&#123; php_version &#125;&#125; --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-jpeg-dir --with-kerberos --with-libdir=lib64 --with-libxml-dir --with-mysql --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-dpo-sqlite --with-pear --with-png-dir --with-openssl --with-xmlrpc --with-xsl --with-zlib --enable-fpm --enable-bcmath --enable-libxml --enable-inline-optimization --enable-gd-native-ttf --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-xml --enable-zip &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -s /usr/local/php-&#123;&#123; php_version &#125;&#125; /usr/local/php - unless: test -d /usr/local/php-&#123;&#123; php_version &#125;&#125; &amp;&amp; test -L /usr/local/php - require: - file: php-install - pkg: pkg-install 3）service.sls123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869[root@salt-master php]# cat service.sls #引入php安装的slsinclude: - modules.php.install#php-ini配置文件配置php-ini: file.managed: - name: /usr/local/php/etc/php.ini - source: salt://modules/php/files/php.ini.template - user: root - group: root - mode: 644 - require: - cmd: php-install cmd.run: - name: ln -s /usr/local/php/etc/php.ini /etc/php.ini - unless: test -L /etc/php.ini - require: - file: php-ini#php-fpm配置文件配置php-fpm: file.managed: - name: /usr/local/php/etc/php-fpm.conf - source: salt://modules/php/files/php-fpm.conf.template - user: root - group: root - mode: 644 - require: - cmd: php-install cmd.run: - name: ln -s /usr/local/php/etc/php-fpm.conf /etc/php-fpm.conf - unless: test -L /etc/php-fpm.conf - require: - file: php-fpm#加入system启动php-systemd: file.managed: - name: /usr/lib/systemd/system/php-fpm.service - source: salt://modules/php/files/php-fpm.service.template - user: root - group: root - mode: 644 - require: - cmd: php-install#加入/etc/init.d/启动php-init: file.managed: - name: /etc/init.d/php-fpm - source: salt://modules/php/files/php-fpm.template - user: root - group: root - mode: 755 - require: - cmd: php-install#启动php-fpmphp-service: service.running: - name: php-fpm - enable: True - require: - file: php-systemd - watch: - file: php-fpm - file: php-ini mysql1）配置文件模板准备123456789[root@salt-master ~]# cd /srv/salt/prod/modules/mysql/[root@salt-master mysql]# tree.├── files│ └── my.cnf├── install.sls└── service.sls1 directory, 3 files 2）install.sls123456[root@salt-master mysql]# cat install.sls mariadb-install: pkg.installed: - pkgs: - mariadb-server - mariadb 3）service.sls1234567891011121314151617181920212223242526[root@salt-master mysql]# cat service.sls #引入mysql安装的slsinclude: - modules.mysql.install#my.cnf配置文件mariadb-config: file.managed: - name: /etc/my.cnf - source: salt://modules/mysql/files/my.cnf - user: root - group: root - mode: 644 - require: - pkg: mariadb-install#启动mariadbmariadb-service: service.running: - name: mariadb - enable: True - watch: - file: mariadb-config - require: - pkg: mariadb-install - file: mariadb-config lnmp1）准备测试文件php info 和nginx虚拟主机配置文件123456789[root@salt-master ~]# cd /srv/salt/prod/modules/lnmp/[root@salt-master lnmp]# tree.├── files│ ├── index.php│ └── www.conf└── www.sls1 directory, 3 files 2）www.sls12345678910111213141516171819202122232425262728293031323334353637383940[root@salt-master lnmp]# cat www.sls #引入nginx、php、mysql的安装include: - modules.nginx.service - modules.php.service - modules.mysql.service#虚拟主机web站点目录创建web-www: file.directory: - name: /opt/www - user: www - group: www - mode: 755#虚拟主机配置文件配置web-www-conf: file.managed: - name: /usr/local/nginx/conf/conf.d/www.conf - source: salt://modules/lnmp/files/www.conf - user: root - group: root - mode: 644 - require: - file: web-www - watch_in: - service: nginx-service - template: jinja - defaults: PORT: 80 IPADDR: &#123;&#123; grains['fqdn_ip4'][0] &#125;&#125;#phpinfo测试文件准备web-index: file.managed: - name: /opt/www/index.php - source: salt://modules/lnmp/files/index.php - user: www - group: www - mode: 644 测试lnmp是否OK1）Top file编写1234[root@salt-master ~]# cat /srv/salt/base/top.sls prod: "salt-minion0[3-4]": - modules.lnmp.www 2）执行高级状态1[root@salt-master ~]# salt '*' state.highstate 3）访问测试 haproxy1）配置文件准备123456789[root@salt-master ~]# cd /srv/salt/prod/modules/haproxy/[root@salt-master haproxy]# tree.├── files│ └── haproxy.cfg├── install.sls└── service.sls1 directory, 3 files 2）install.sls1234[root@salt-master haproxy]# cat install.sls haproxy-install: pkg.installed: - name: haproxy 3）service.sls1234567891011121314151617181920212223242526[root@salt-master haproxy]# cat service.sls #引入haproxy安装的slsinclude: - modules.haproxy.install#配置文件haproxy-config: file.managed: - name: /etc/haproxy/haproxy.cfg - source: salt://modules/haproxy/files/haproxy.cfg - user: root - group: root - mode: 644 - require: - pkg: haproxy-install#启动haproxyhaproxy-service: service.running: - name: haproxy - enable: True - require: - pkg: haproxy-install - file: haproxy-config - watch: - file: haproxy-config keepalived1）配置文件准备123456789[root@salt-master ~]# cd /srv/salt/prod/modules/keepalived/[root@salt-master keepalived]# tree.├── files│ └── keepalived.conf├── install.sls└── service.sls1 directory, 3 files 2）install.sls1234[root@salt-master keepalived]# cat install.sls keepalived-install: pkg.installed: - name: keepalived 3）service.sls12345678910111213141516171819202122232425262728293031323334353637[root@salt-master keepalived]# cat service.sls #引入keepalived安装的slsinclude: - modules.keepalived.install#keepalived配置文件keepalived-config: file.managed: - name: /etc/keepalived/keepalived.conf - source: salt://modules/keepalived/files/keepalived.conf - user: root - group: root - mode: 644 - require: - pkg: keepalived-install - template: jinja - defaults:&#123;% if grains['fqdn'] == "salt-minion01" %&#125; ROUTER_ID: saltstack01 STATE: MASTER PRIORITY: 150&#123;% elif grains['fqdn'] == "salt-minion02" %&#125; ROUTER_ID: saltstack02 STATE: BACKUP PRIORITY: 100&#123;% endif %&#125;#启动keepalivedkeepalived-service: service.running: - name: keepalived - enable: True - require: - pkg: keepalived-install - file: keepalived-config - watch: - file: keepalived-config 整体部署1）top file 编写12345678[root@salt-master ~]# cat /srv/salt/base/top.sls prod: "salt-minion0[3-4]": - modules.lnmp.www "salt-minion0[1-2]": - modules.haproxy.service - modules.keepalived.service 2）高级状态执行1[root@salt-master ~]# salt '*' state.highstate 3）测试访问192.168.1.31和192.168.1.32的状态页访问VIP192.168.1.100 通过上面测试可看到可以成功访问lnmp站点，并且haproxy也ok。访问所有四台服务器都可以得到phpinfo页面，而在生产环境中，我们只是对外提供vip即可。 项目总结1）整体环境查看1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@salt-master ~]# tree /srv/salt/prod/modules//srv/salt/prod/modules/├── haproxy│ ├── files│ │ └── haproxy.cfg│ ├── install.sls│ └── service.sls├── keepalived│ ├── files│ │ └── keepalived.conf│ ├── install.sls│ └── service.sls├── lnmp│ ├── files│ │ ├── index.php│ │ └── www.conf│ └── www.sls├── mysql│ ├── files│ │ └── my.cnf│ ├── install.sls│ └── service.sls├── nginx│ ├── files│ │ ├── nginx-1.12.2.tar.gz│ │ ├── nginx-1.16.0.tar.gz│ │ ├── nginx.conf.template│ │ └── nginx.service.template│ ├── install.sls│ └── service.sls├── php│ ├── files│ │ ├── php-5.6.40.tar.gz│ │ ├── php-fpm.conf.template│ │ ├── php-fpm.service.template│ │ ├── php-fpm.template│ │ └── php.ini.template│ ├── install.sls│ └── service.sls├── pkg.sls└── user └── www.sls13 directories, 27 files 2）如果需要在某台服务器上面单独部署某一部分，参考以下写法：123456789101112131415161718192021[root@salt-master ~]# cat /srv/salt/base/top.sls #部署lnmp及haproxy+keepalivedprod: "salt-minion0[3-4]": - modules.lnmp.www "salt-minion0[1-2]": - modules.haproxy.service - modules.keepalived.service#单实例操作说明：prod: "salt-minion04": - modules.nginx.service #单独安装nginx时 - modules.mysql.service #单独安装mysql时 - modules.php.service #单独安装php时 - modules.keepalived.service #单独安装keepalived时 - modules.haproxy.service #单独安装haproxy时 "salt-minion03": - modules.lnmp.www #单独部署lnmp环境时]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack接口salt-api]]></title>
    <url>%2F2019%2F05%2F20%2Fsaltstack%E6%8E%A5%E5%8F%A3salt-api%2F</url>
    <content type="text"><![CDATA[介绍参考官档参考官档 SaltStack官方提供有REST API格式的salt-api项目，将使salt与第三方系统集成变得更加简单。 salt-api安装配置1）在salt-master上进行安装1[root@salt-master ~]# yum -y install salt-api 2）自签名证书，生产环境可以购买（说明：如果没有salt-call命令，装上salt-minion即可，依赖于该包）123[root@salt-master ~]# salt-call --local tls.create_self_signed_certlocal: Created Private Key: "/etc/pki/tls/certs/localhost.key." Created Certificate: "/etc/pki/tls/certs/localhost.crt." 3）打开include加载子配置文件，方便管理12[root@salt-master ~]# vim /etc/salt/masterdefault_include: master.d/*.conf 4）配置api配置文件，将上面生成的证书写到配置文件123456[root@salt-master ~]# vim /etc/salt/master.d/api.confrest_cherrypy: host: 192.168.1.30 port: 8000 ssl_crt: /etc/pki/tls/certs/localhost.crt ssl_key: /etc/pki/tls/certs/localhost.key 5）创建认证用户，并设置密码12[root@salt-master ~]# useradd -M -s /sbin/nologin saltapi[root@salt-master ~]# echo 'saltapi' | passwd --stdin saltapi 6）创建认证配置文件12345678[root@salt-master ~]# vim /etc/salt/master.d/auth.confexternal_auth: pam: saltapi: - .* - '@wheel' - '@runner' - '@jobs' 7）重启salt-master和启动salt-api12[root@salt-master ~]# systemctl restart salt-master[root@salt-master ~]# systemctl start salt-api 8）查看salt-api监听端口123[root@salt-master ~]# netstat -anlutp |grep 8000tcp 0 0 192.168.1.30:8000 0.0.0.0:* LISTEN 10904/python tcp 0 0 192.168.1.30:53414 192.168.1.30:8000 TIME_WAIT - 9）验证login登录，获取token字符串12345678910111213141516[root@salt-master ~]# curl -sSk https://192.168.1.30:8000/login \&gt; -H 'Accept: application/x-yaml' \&gt; -d username=saltapi \&gt; -d password=saltapi \&gt; -d eauth=pamreturn:- eauth: pam expire: 1558663247.869537 perms: - .* - '@wheel' - '@runner' - '@jobs' start: 1558620047.869536 token: e8330f642a3addd853c723d63844d29a12de9484 user: saltapi 10）通过api执行test.ping测试连通性1234567891011[root@salt-master ~]# curl -sSk https://192.168.1.30:8000 \&gt; -H 'Accept: application/x-yaml' \&gt; -H 'X-Auth-Token: e8330f642a3addd853c723d63844d29a12de9484'\&gt; -d client=local \&gt; -d tgt='*' \&gt; -d fun=test.pingreturn:- salt-minion01: true salt-minion02: true salt-minion03: true salt-minion04: true 11）通过api执行cmd.run1234567891011[root@salt-master ~]# curl -sSk https://192.168.1.30:8000 \&gt; -H 'Accept: application/x-yaml' \&gt; -H 'X-Auth-Token: e8330f642a3addd853c723d63844d29a12de9484'\&gt; -d client=local \&gt; -d tgt='*' \&gt; -d fun='cmd.run' -d arg='uptime'return:- salt-minion01: ' 22:10:25 up 46 min, 1 user, load average: 0.00, 0.01, 0.05' salt-minion02: ' 22:10:25 up 7 min, 0 users, load average: 0.00, 0.18, 0.15' salt-minion03: ' 22:10:25 up 7 min, 0 users, load average: 0.06, 0.33, 0.26' salt-minion04: ' 22:10:25 up 7 min, 0 users, load average: 0.01, 0.21, 0.16' 12）通过api获取grains信息`123456789101112131415[root@salt-master ~]# curl -sSk https://192.168.1.30:8000/minions/salt-minion01 \&gt; -H 'Accept: application/x-yaml' \&gt; -H 'X-Auth-Token: e8330f642a3addd853c723d63844d29a12de9484'return:- salt-minion01: SSDs: [] biosreleasedate: 05/19/2017 biosversion: '6.00' cpu_flags: - fpu - vme - de - pse - tsc..... 13）使用json格式12345[root@salt-master ~]# curl -sSk https://192.168.1.30:8000/minions/salt-minion01 \&gt; -H 'Accept: application/json' \&gt; -H 'X-Auth-Token: e8330f642a3addd853c723d63844d29a12de9484'&#123;"return": [&#123;"salt-minion01": &#123;"biosversion": "6.00", "kernel": "Linux", "domain": "", "uid": 0, "zmqversion": "4.1.4", "kernelrelease": "3.10.0-693.el7.x86_64", "selinux": &#123;"enforced": "Disabled", "enabled": false&#125;, "serialnumber": "VMware-56 4d 9e a0 21 56 90 87-cd 89 69 32 13 94 17 44", "pid": 1449, "fqdns": [], "ip_interfaces": &#123;"lo": ["127.0.0.1", "::1"], "virbr0": ["192.168.122.1"], "virbr0-nic": [], "ens33": ["192.168.1.31", "192.168.1.100", "fe80::20c:29ff:fe94:1744"]&#125;, "groupname": "root", "fqdn_ip6": ["fe80::20c:29ff:fe94:1744"],....... 总结 salt-api必须使用https，生产环境建议使用可信证书当salt-api服务重启后原token失效]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack使用salt-ssh]]></title>
    <url>%2F2019%2F05%2F20%2Fsaltstack%E4%BD%BF%E7%94%A8salt-ssh%2F</url>
    <content type="text"><![CDATA[salt-ssh 介绍参考官档 salt-ssh是 0.17.0 新引入的一个功能，不需要minion对客户端进行管理，也可以不需要master；salt-ssh也支持salt大部分的功能：比如grains,modules,state等；salt-ssh没有使用ZeroMQ的通信架构，执行是串行模式 salt-ssh执行原理 salt-ssh是在salt基础上打了一个python包上传到客户端的默认tmp目录下, 在客户端上面解压并执行返回结果,最后删除tmp上传的临时文件。 salt-minion方法是salt-mater先执行语法验证，验证通过后发送到minion，minion收到Msater的状态文件默认保存在/var/cache/salt/minion salt-ssh和salt-minion可以共存，salt-minion不依赖于ssh服务 安装配置1）安装salt-ssh1[root@salt-master ~]# yum -y install salt-ssh 2）修改roster文件，配置需要管理的机器123456789101112[root@salt-master ~]# vim /etc/salt/rostersalt-minion01: host: 192.168.1.31 user: root passwd: 123456 port: 22salt-minion02: host: 192.168.1.32 user: root passwd: 123456 port: 22 3）管理测试 (说明，如果第一次需要输入yes或no进行ssh认证，可以加-i参数自动认证)12345[root@salt-master ~]# salt-ssh '*' test.ping -isalt-minion01: Truesalt-minion02: True 4）salt-ssh命令参数12345678910-r, –raw, –raw-shell # 直接使用shell命令–priv #指定SSH私有密钥文件–roster #定义使用哪个roster系统，如果定义了一个后端数据库，扫描方式，或者用户自定义的的roster系统，默认的就是/etc/salt/roster文件–roster-file #指定roster文件–refresh, –refresh-cache #刷新cache，如果target的grains改变会自动刷新–max-procs #指定进程数，默认为25-i, –ignore-host-keys #当ssh连接时，忽略keys–passwd #指定默认密码–key-deploy #配置keys 设置这个参数对于所有minions用来部署ssh-key认证， 这个参和–passwd结合起来使用会使初始化部署很快很方便。当调用master模块时，并加上参数 –key-deploy 即可在minions生成keys，下次开始就不使用密码 5）salt-ssh执行命令1234567891011121314151617[root@salt-master ~]# salt-ssh '*' -r "uptime"salt-minion01: ---------- retcode: 0 stderr: stdout: root@192.168.1.31's password: 10:06:08 up 1 day, 17:05, 2 users, load average: 0.00, 0.01, 0.05salt-minion02: ---------- retcode: 0 stderr: stdout: root@192.168.1.32's password: 10:06:08 up 1 day, 17:16, 2 users, load average: 0.03, 0.06, 0.06 6）salt-ssh执行状态模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[root@salt-master ~]# salt-ssh '*' state.sls modules.haproxy.service saltenv=prodsalt-minion02:---------- ID: haproxy-install Function: pkg.installed Name: haproxy Result: True Comment: All specified packages are already installed Started: 10:09:48.541019 Duration: 10161.705 ms Changes: ---------- ID: haproxy-config Function: file.managed Name: /etc/haproxy/haproxy.cfg Result: True Comment: File /etc/haproxy/haproxy.cfg is in the correct state Started: 10:09:59.020659 Duration: 54.263 ms Changes: ---------- ID: haproxy-service Function: service.running Name: haproxy Result: True Comment: The service haproxy is already running Started: 10:09:59.079110 Duration: 128.052 ms Changes: Summary for salt-minion02------------Succeeded: 3Failed: 0------------Total states run: 3Total run time: 10.344 ssalt-minion01:---------- ID: haproxy-install Function: pkg.installed Name: haproxy Result: True Comment: All specified packages are already installed Started: 10:10:00.561015 Duration: 2862.018 ms Changes: ---------- ID: haproxy-config Function: file.managed Name: /etc/haproxy/haproxy.cfg Result: True Comment: File /etc/haproxy/haproxy.cfg is in the correct state Started: 10:10:03.905713 Duration: 220.443 ms Changes: ---------- ID: haproxy-service Function: service.running Name: haproxy Result: True Comment: The service haproxy is already running Started: 10:10:04.135607 Duration: 230.231 ms Changes: Summary for salt-minion01------------Succeeded: 3Failed: 0------------Total states run: 3Total run time: 3.313 s Roster说明 salt-ssh需要一个名单系统来确定哪些执行目标，Salt的0.17.0版本中salt-ssh引入roster系统roster系统编译成了一个数据结构，包含了targets，这些targets是一个目标系统主机列表和或如连接到这些targets。 配置文件说明：12345678910111213# target的信息 host: # 远端主机的ip地址或者dns域名 user: # 登录的用户 passwd: # 用户密码,如果不使用此选项，则默认使用秘钥方式# 可选的部分 port: #ssh端口 sudo: #可以通过sudo tty: # 如果设置了sudo，设置这个参数为true priv: # ssh秘钥的文件路径 timeout: # 当建立链接时等待响应时间的秒数 minion_opts: # minion的位置路径 thin_dir: # target系统的存储目录，默认是/tmp/salt-&lt;hash&gt; cmd_umask: # 使用salt-call命令的umask值]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack数据系统]]></title>
    <url>%2F2019%2F05%2F17%2Fsaltstack%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[数据系统Grains 1、Grains是SaltStack收集的有关底层管理系统的静态信息。包括操作系统版本、域名、IP地址、内存、内核、CPU、操作系统类型以及许多其他系统属性。Minion 收集的信息，可以作为Master端匹配目标。2、如果需要自定义grains，需要添加到Salt Minion的/etc/salt/grains文件中（配置文件中定义的默认路径），也可以直接写在配置文件/etc/salt/minion中 Grains官方文档1）资产管理，信息查询12345678#列出所有可用的grains状态模块[root@salt-master ~]# salt '*' grains.ls#打印所有状态信息[root@salt-master ~]# salt '*' grains.items#列出每台minion的本地IP地址[root@salt-master ~]# salt '*' grains.item fqdn_ip4#列出每台minion的操作系统[root@salt-master ~]# salt '*' grains.item os 2）用于匹配12[root@salt-master ~]# salt -G 'os:CentOS' test.ping[root@salt-master ~]# salt -G 'localhost:salt-minion01' test.ping 3）minion自定义grains12345678910111213141516#1.修改配置文件，自定义grains[root@salt-minion01 ~]# vim /etc/salt/miniongrains: roles: - webserver - memcache ipaddr: - 192.168.1.32#2.重启minion[root@salt-minion01 ~]# systemctl restart salt-minion#3.master上测试[root@salt-master ~]# salt -G 'ipaddr:192.168.1.32' test.ping salt-minion01: True 4）Grains优先级问题1231、Grains默认核心信息2、自定义写在/etc/salt/grains文件中的3、自定义写在/etc/salt/minion文件中的 数据系统Pillar Pillar是动态的，Pillar存储在master上，提供给minion。Pillar主要记录一些加密信息，可以确保这些敏感数据不被其他minion看到。比如：软件版本号、用户名密码等。存储格式都是YAML格式 1）在Master端定义Pillar123456789[root@salt-master ~]# vim /etc/salt/masterpillar_roots: base: - /srv/pillar[root@salt-master ~]# mkdir /srv/pillar[root@salt-master ~]# cat /srv/pillar/zabbix.sls Zabbix_Server: 192.168.1.11Zabbix_Name: zabbix.examp.com 2）编写TopFile指定Minion端可以使用1234[root@salt-master ~]# cat /srv/pillar/top.sls base: 'salt-minion01': - zabbix 3）刷新Pillar1[root@salt-master ~]# salt '*' saltutil.refresh_pillar 4）获取对应pillar值123456789101112131415161718[root@salt-master ~]# salt '*' pillar.itemssalt-minion01: ---------- Zabbix_Name: zabbix.examp.com Zabbix_Server: 192.168.1.11salt-minion03: ----------salt-minion02: ----------#获取指定的key[root@salt-master ~]# salt 'salt-minion01' pillar.item Zabbix_Serversalt-minion01: ---------- Zabbix_Server: 192.168.1.11 说明：如果Master更新了新的数值，需要刷新Pillar到Minion才可以获取 Pirrar与Grains对比123类型 数据采集方式 应用场景 定义位置Grains 静态 minion启动时收集 数据查询 目标选择 配置管理 minionPillar 动态 master进行自定义 目标选择 配置管理 敏感数据 master]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack状态判断unless与onlyif]]></title>
    <url>%2F2019%2F05%2F17%2Fsaltstack%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%ADunless%E4%B8%8Eonlyif%2F</url>
    <content type="text"><![CDATA[很多时候我们在编写state 文件时候需要进行判断，判断该目录或文件是否存在，判断该配置是否已经已添加，然后根据判断结果再决定命令或动作是否执行，这时候就需要用到了状态判断的unless和onlyif。 unlessunless示例：需求创建/tmp/unless.txt文件，存在则不创建，不存在则创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[root@salt-master ~]# cat /srv/salt/prod/unless.sls test-unless: cmd.run: - name: touch /tmp/unless.txt - unless: test -f /tmp/unless.txt[root@salt-master ~]# salt 'salt-minion01' state.sls unless saltenv=prodsalt-minion01:---------- ID: test-unless Function: cmd.run Name: touch /tmp/unless.txt Result: True Comment: Command "touch /tmp/unless.txt" run Started: 15:10:51.522319 Duration: 31.822 ms Changes: ---------- pid: 6538 retcode: 0 stderr: stdout:Summary for salt-minion01------------Succeeded: 1 (changed=1)Failed: 0------------Total states run: 1Total run time: 31.822 ms#上面第一次执行，可以看到发生了一次更改，创建了 /tmp/unless.txt文件[root@salt-master ~]# salt 'salt-minion01' state.sls unless saltenv=prodsalt-minion01:---------- ID: test-unless Function: cmd.run Name: touch /tmp/unless.txt Result: True Comment: unless condition is true Started: 15:11:40.819789 Duration: 10.477 ms Changes: Summary for salt-minion01------------Succeeded: 1Failed: 0------------Total states run: 1Total run time: 10.477 ms#第二次执行，可以看到该文件已经存在，并没有再次创建 通过上面的小案例可以看出，当unless返回为真则不执行，当unless返回为假才执行。 onlyif onlyif正好和unless相反，当onlyif返回为真执行，当onlyif返回为假不执行 onlyif示例：需求，当/tmp/onlyif.txt文件存在，则创建/tmp/onlyif目录，不存在，则不创建/tmp/onlyif目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[root@salt-master ~]# cat /srv/salt/prod/onlyif.sls test-onlyif: cmd.run: - name: mkdir /tmp/onlyif - onlyif: test -f /tmp/onlyif.txt[root@salt-master ~]# salt 'salt-minion01' state.sls onlyif saltenv=prodsalt-minion01:---------- ID: test-onlyif Function: cmd.run Name: mkdir /tmp/onlyif Result: True Comment: onlyif condition is false Started: 15:34:56.460583 Duration: 9.612 ms Changes: Summary for salt-minion01------------Succeeded: 1Failed: 0------------Total states run: 1Total run time: 9.612 ms#通过上面可以看到，由于/tmp/onlyif.txt文件不存在，并没有创建；手动创建一个/tmp/onlyif.txt文件再次执行[root@salt-master ~]# salt 'salt-minion01' cmd.run "touch /tmp/onlyif.txt"salt-minion01:[root@salt-master ~]# salt 'salt-minion01' state.sls onlyif saltenv=prodsalt-minion01:---------- ID: test-onlyif Function: cmd.run Name: mkdir /tmp/onlyif Result: True Comment: Command "mkdir /tmp/onlyif" run Started: 15:38:07.712492 Duration: 14.646 ms Changes: ---------- pid: 6871 retcode: 0 stderr: stdout:Summary for salt-minion01------------Succeeded: 1 (changed=1)Failed: 0------------Total states run: 1Total run time: 14.646 ms#可以看到上面我们手动创建了一个/tmp/onlyif.txt文件后再次执行，则发生了改变，在/tmp/创建了onlyif目录 Redis主从架构案例说明：该案例在prod环境配置 1）环境准备，定义file_roots环境12345678[root@salt-master ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt/base dev: - /srv/salt/dev prod: - /srv/salt/prod 2）创建对应环境目录12[root@salt-master ~]# mkdir -p /srv/salt/&#123;base,dev,prod&#125;[root@salt-master ~]# mkdir -p /srv/salt/prod/redis/files/ 3）编写state sls状态文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#初始化redis（安装和基本配置）[root@salt-master ~]# cat /srv/salt/prod/redis/init.sls redis-install: pkg.installed: - name: redisredis-config: file.managed: - name: /etc/redis.conf - source: salt://redis/files/redis.conf - user: root - group: root - mode: 644 - template: jinja - defaults: BIND: &#123;&#123; grains['fqdn_ip4'][0] &#125;&#125; PORT: 6379 DAEMONIZA: 'yes' - require: - pkg: redis-installredis-service: service.running: - name: redis - enable: True - watch: - file: redis-config#master直接引入 init[root@salt-master ~]# cat /srv/salt/prod/redis/master.sls include: - redis.init#slave引入init 并配置主从信息[root@salt-master ~]# cat /srv/salt/prod/redis/slave.sls include: - redis.init#配置主从slave-config: cmd.run: - name: redis-cli -h 192.168.1.34 slaveof 192.168.1.33 6379 - unless: redis-cli -h 192.168.1.34 info |grep role:slave - require: - service: redis-service说明：unless：返回为真则不执行，反之为假则执行 4）配置文件准备123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[root@salt-master ~]# grep "^[a-Z]" /etc/redis.conf &gt;&gt;/srv/salt/prod/redis/files/redis.conf[root@salt-master ~]# cat /srv/salt/prod/redis/files/redis.conf #这里使用jinjabind &#123;&#123; BIND &#125;&#125;protected-mode yes#这里使用jinjaport &#123;&#123; PORT &#125;&#125;tcp-backlog 511timeout 0tcp-keepalive 300#这里使用jinjadaemonize &#123;&#123; DAEMONIZA &#125;&#125;supervised nopidfile /var/run/redis_6379.pidloglevel noticelogfile /var/log/redis/redis.logdatabases 16save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir /var/lib/redisslave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay noslave-priority 100appendonly noappendfilename "appendonly.aof"appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events ""hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes 5）top file文件编写123456[root@salt-master ~]# cat /srv/salt/base/top.sls prod: 'salt-minion02': - redis.master 'salt-minion03': - redis.slave 6）整体state文件查看123456789[root@salt-master ~]# tree /srv/salt/prod/redis//srv/salt/prod/redis/├── files│ └── redis.conf├── init.sls├── master.sls└── slave.sls1 directory, 4 files 7）top file高级状态执行123#先测试下看下状态文件是否编写正确，再正式执行[root@salt-master ~]# salt '*' state.highstate test=True[root@salt-master ~]# salt '*' state.highstate]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack配置管理]]></title>
    <url>%2F2019%2F05%2F15%2Fsaltstack%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Saltstack状态模块 远程执行模块的执行是过程式，而状态是对minion的一种描述和定义，管理人员不需要关系部署任务如何完成的，只需要描述minion的状态描述。它的和兴是写sls(Salt State file)文件，sls文件默认格式为YAML格式，并默认使用jinja模板，jinja是根据django的模板语言发展而来的语言，简单并强大，支持for if等循环语句。salt state主要用来描述系统，服务，配置文件的状态，常常被称为配置管理。 12345678910mysql-install: #ID声明，必须唯一 pkg.installed: #state状态声明 - pkgs: #选项声明 - mariadb: #选项列表 - mariadb-server说明：一个ID只能出现一次一个ID下相同模块只能使用一次一个ID下不可以使用多个不同模块 模块帮助手册12345678#列出所有状态模块[root@salt-master ~]# salt '*' sys.list_modules#查看指定模块的所有方法[root@salt-master ~]# salt '*' sys.list_state_functions pkg#查看指定模块的使用方法[root@salt-master ~]# salt '*' sys.state_doc pkg#查看指定模块的指定方法的用法[root@salt-master ~]# salt '*' sys.state_doc pkg.installed pkg软件模块pkg模块官档pkg.installed 软件安装1234567php-install: pkg.installed: - pkgs: - php - php-mysql: "&gt;=5.4.16" #指定安装版本 - php-pdo - php-cli 指定安装最新版本的软件1234567php-install: pkg.latest: - pkgs: - php - php-mysql - php-pdo - php-cli file文件模块file模块官档file.managed 下发文件，确保文件存在1234567891011121314151617181920212223[root@salt-master ~]# mkdir /srv/salt/base/files[root@salt-master ~]# cp /etc/httpd/conf/httpd.conf /srv/salt/base/files/[root@salt-master ~]# cat /srv/salt/base/apache_conf.slsapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644说明：- name: 表示存放目的地址- source: 表示这个文件来自哪里（说明这个文件得提前准备）或者这样写，直接已目的地址命令ID，这样ID也表示目的地址[root@salt-master ~]# cat /srv/salt/base/apache_conf.sls/etc/httpd/conf/httpd.conf: file.managed: - source: salt://files/httpd.conf - user: root - group: root - mode: 644 1234567891011121314151617小示例：[root@salt-master ~]# cat /srv/salt/base/test.sls/tmp/passwd_back: file.managed: - source: salt://files/passwd - user: root - group: root - mode: 644[root@salt-master ~]# cp /etc/passwd /srv/salt/base/files/[root@salt-master ~]# salt '*' state.sls test[root@salt-master ~]# salt '*' cmd.run "ls -l /tmp/passwd_back"salt-minion03: -rw-r--r-- 1 root root 2098 May 15 16:21 /tmp/passwd_backsalt-minion02: -rw-r--r-- 1 root root 2098 May 15 16:21 /tmp/passwd_backsalt-minion01: -rw-r--r-- 1 root root 2098 May 15 16:21 /tmp/passwd_back file.directory 建立目录12345678910111213141516[root@salt-master ~]# cat /srv/salt/base/directory.sls/tmp/saltdir: file.directory: - user: root - group: root - mode: 755 - makedirs: True #如果上一级目录不存在自动创建；类似（mkdir -p）[root@salt-master ~]# salt '*' state.sls directory[root@salt-master ~]# salt '*' cmd.run "ls -d /tmp/saltdir"salt-minion03: /tmp/saltdirsalt-minion02: /tmp/saltdirsalt-minion01: /tmp/saltdir file.recurse 下发整个目录1234567891011[root@salt-master ~]# cat /srv/salt/base/httpd_conf_dir.slshttpd_conf_dir: file.recurse: - name: /etc/httpd/conf.d - source: salt://files/conf.d - file_mode: 600 #文件权限 - dir_mode: 755 #目录权限 - include_empty: True #同步空目录 - clean: True #使用后minion与master保持一致[root@salt-master ~]# rsync -avh /etc/httpd/conf.d /srv/salt/base/files/ file.symlink 建立软链接12345678910111213[root@salt-master ~]# cat /srv/salt/base/target_link.sls/etc/grub.cfg: file.symlink: - target: /etc/grub2.cfg[root@salt-master ~]# salt '*' state.sls target_link[root@salt-master ~]# salt '*' cmd.run "ls -l /etc/grub.cfg"salt-minion03: lrwxrwxrwx 1 root root 14 May 15 16:42 /etc/grub.cfg -&gt; /etc/grub2.cfgsalt-minion01: lrwxrwxrwx 1 root root 14 May 15 16:42 /etc/grub.cfg -&gt; /etc/grub2.cfgsalt-minion02: lrwxrwxrwx 1 root root 14 May 15 16:42 /etc/grub.cfg -&gt; /etc/grub2.cfg service服务模块service模块官档12345678910111213[root@salt-master ~]# cat /srv/salt/base/service_httpd.slshttpd: service.running: - name: httpd #服务名称 - enable: True #开机自启动 - reload: True #允许重载配置文件，不写则是restart或者这样写[root@salt-master ~]# cat /srv/salt/base/service_httpd.slshttpd: #即表示ID，又表示服务名 service.running: - enable: True - reload: True 高级状态模块 当我们想要不同的主机应用不同的配置，那么可以使用高级状态管理 top file来进行管理。可以通过正则，grain模块，或分组名，来进行匹配，再下一级是要执行的state文件 可以将我们的配置需求转换为YAML并在Top file文件中表示： Top file示例1234567891011base: '*': #通过正则去匹配所有minion - app.nginx webserver: #定义的分组名称 - match: nodegroup - app.cron 'os:centos': #通过grains模块匹配 - match: grains - nginx Top file 高级状态的执行1[root@salt-master ~]# salt '*' state.highstate LAMP架构案例说明：该案例在prod环境配置1）环境准备，定义file_roots环境12345678[root@salt-master ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt/base dev: - /srv/salt/dev prod: - /srv/salt/prod 2）创建对应环境目录12[root@salt-master ~]# mkdir -p /srv/salt/&#123;base,dev,prod&#125;[root@salt-master ~]# mkdir /srv/salt/prod/&#123;httpd,php,mysql,files&#125; 3）配置文件准备及测试文件准备12345[root@salt-master ~]# cp /etc/my.cnf /srv/salt/prod/files/[root@salt-master ~]# cp /etc/httpd/conf/httpd.conf /srv/salt/prod/files/[root@salt-master ~]# cp /etc/php.ini /srv/salt/prod/files/[root@salt-master ~]# echo "&lt;h1&gt;LAMP html&lt;/h1&gt;" &gt;&gt;/srv/salt/prod/files/index.html[root@salt-master ~]# echo "&lt;?php phpinfo(); ?&gt;" &gt;&gt; /srv/salt/prod/files/index.php 4）编写state sls状态文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#httpd[root@salt-master ~]# cat /srv/salt/prod/httpd/init.slsapache-install: pkg.installed: - pkgs: - httpd - httpd-toolsapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644apache-service: service.running: - name: httpd - enable: True#php[root@salt-master ~]# cat /srv/salt/prod/php/init.slsphp-install: pkg.installed: - pkgs: - php - php-mysql - php-pdo - php-cliphp-config: file.managed: - name: /etc/php.ini - source: salt://files/php.ini - user: root - group: root - mode: 644#mysql[root@salt-master ~]# cat /srv/salt/prod/mysql/init.slsmariadb-install: pkg.installed: - pkgs: - mariadb-server - mariadbmariadb-config: file.managed: - name: /etc/my.cnf - source: salt://files/my.cnf - user: root - group: root - mode: 644mariadb-service: service.running: - name: mariadb - enable: True#测试文件[root@salt-master ~]# cat /srv/salt/prod/testfile.sls/var/www/html/index.html: file.managed: - source: salt://files/index.html/var/www/html/index.php: file.managed: - source: salt://files/index.php 6）topfile文件编写1234567[root@salt-master ~]# cat /srv/salt/base/top.slsprod: 'salt-minion*': - httpd.init - php.init - mysql.init - testfile 7）部署LAMP整体state文件查看12345678910111213141516171819[root@salt-master ~]# tree /srv/salt//srv/salt/├── base│ └── top.sls├── dev└── prod ├── files │ ├── httpd.conf │ ├── index.html │ ├── index.php │ ├── my.cnf │ └── php.ini ├── httpd │ └── init.sls ├── mysql │ └── init.sls ├── php │ └── init.sls └── testfile.sls 8）执行topfile1[root@salt-master ~]# salt '*' state.highstate States状态依赖通过上面的lamp可以看出已经可以使用state模块来定义minion的状态了，但是如果一个主机涉及多个状态，并且状态之间相互关联，在执行顺序上有先后之分，那么必须引用requisites来进行控制 关系说明：1、require 我依赖某个状态，我依赖谁2、require_in 我被某个状态依赖，谁依赖我3、watch 我关注某个状态，当状态发生改变，进行restart或者reload操作4、watch_in 我被某个状态关注5、include 我引用谁 1）修改上面lamp状态间依赖关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#httpd[root@salt-master ~]# cat /srv/salt/prod/httpd/init.slsapache-install: pkg.installed: - pkgs: - httpd - httpd-toolsapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644 - require: - pkg: apache-install #表示上面apache-install执行成功，才能执行apache-configapache-service: service.running: - name: httpd - enable: True - require: - file: apache-config - watch: - file: apache-config#php[root@salt-master ~]# cat /srv/salt/prod/php/init.slsphp-install: pkg.installed: - pkgs: - php - php-mysql - php-pdo - php-cli - reqiure_in: - file: php-configphp-config: file.managed: - name: /etc/php.ini - source: salt://files/php.ini - user: root - group: root - mode: 644#mysql[root@salt-master ~]# cat /srv/salt/prod/mysql/init.slsmariadb-install: pkg.installed: - pkgs: - mariadb-server - mariadbmariadb-config: file.managed: - name: /etc/my.cnf - source: salt://files/my.cnf - user: root - group: root - mode: 644 - require: - pkg: mariadb-installmariadb-service: service.running: - name: mariadb - enable: True - reload: True - require: - file: mariadb-config - watch: - file: mariadb-config 2）修改引用关系后include1234567891011121314151617181920212223242526272829303132[root@salt-master ~]# tree /srv/salt//srv/salt/├── base│ └── top.sls├── dev└── prod ├── files │ ├── httpd.conf │ ├── index.html │ ├── index.php │ ├── my.cnf │ └── php.ini ├── httpd │ └── init.sls ├── lamp.sls ├── mysql │ └── init.sls ├── php │ └── init.sls └── testfile.sls[root@salt-master ~]# cat /srv/salt/prod/lamp.slsinclude: - httpd.init - php.init - mysql.init - testfile[root@salt-master ~]# cat /srv/salt/base/top.slsprod: 'salt-minion*': - lamp 3）编写SLS技巧 1、按照状态分类，如果单独使用，清晰明了2、按照服务分类，可以被其它SLS引用 Jinja模板使用 配置文件一般灵活多变，比如配置apache的IP地址或者端口PORT等，则可以动态传值。Jinja官档salt jinja官档 Jinja2 模板包含变量和表达式，变量用 &#123;&#123; … &#125;&#125; 包围，表达式用 &#123;&#37; … &#37;&#125; 包围。变量使用示例：123456789101112131415161718192021222324252627282930313233[root@salt-master ~]# cat /srv/salt/base/var.sls &#123;% set var= 'hello world!' %&#125;test_var: cmd.run: - name: echo "测试变量 &#123;&#123; var &#125;&#125;"[root@salt-master ~]# salt 'salt-minion01' state.sls varsalt-minion01:---------- ID: test_var Function: cmd.run Name: echo "测试变量 hello world!" Result: True Comment: Command "echo "测试变量 hello world!"" run Started: 14:50:58.302424 Duration: 12.358 ms Changes: ---------- pid: 22510 retcode: 0 stderr: stdout: 测试变量 hello world!Summary for salt-minion01------------Succeeded: 1 (changed=1)Failed: 0------------Total states run: 1Total run time: 12.358 ms jinja2 常用变量1、字符串类型12&#123;% set var = 'test' %&#125; #定义变量&#123;&#123; var &#125;&#125; #调用变量 2、列表类型12&#123;% set list = ['one', 'two', 'three'] %&#125;&#123;&#123; list[1] &#125;&#125; #获取变量的第一个值 3、字典类型12&#123;% set dict = &#123;'key1':'value1', 'key2':'value2'&#125; %&#125;&#123;&#123; dict['key1'] &#125;&#125; #获取'key1'的值 示例1：Saltstack使用jinja模块配置apache监听端口12345678910111213141516171819202122#1.告诉file状态模块，需要使用jinja - template: jinja#2.列出参数列表 - defaults: PORT: 8000#3.配置文件引用jinja模板&#123;&#123; PORT &#125;&#125;# 配置示例apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644 - template: jinja - defaults: PORT: 8000# 修改httpd.conf配置文件引用变量Listen &#123;&#123; PORT &#125;&#125; 示例2：使用grinas 方式进行赋值123456789101112131415#配置示例apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644 - template: jinja - defaults: PORT: 8000 IPADDR: &#123;&#123; grains['fqdn_ip4'][0] &#125;&#125;# 修改httpd.conf配置文件引用变量Listen &#123;&#123; IPADDR &#125;&#125;:&#123;&#123; PORT &#125;&#125; 示例3：通过jinja+grains根据系统不同安装apache123456789[root@salt-master ~]# cat /srv/salt/base/httpd.sls#根据grains获取的值判别系统后安装软件httpd-install: pkg.installed:&#123;% if grains['os'] == 'CentOS' %&#125; - name: httpd&#123;% elif grains['OS'] == 'Debin' %&#125; - name: apache2&#123;% endif %&#125;]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack基本入门]]></title>
    <url>%2F2019%2F05%2F13%2Fsaltstack%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[saltstack介绍Salt，,一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯 主要功能远程执行配置管理Stalstack官方文档 Saltstack原理 Salt使用server-agent通信模型，服务端组件被称为Salt master，agent被称为Salt minionSalt master主要负责向Salt minions发送命令，然后聚合并显示这些命令的结果。一个Salt master可以管理多个minion系统Salt server与Salt minion通信的连接由Salt minion发起，这也意味着Salt minion上不需要打开任何传入端口（从而减少攻击）。Salt server使用端口4505和4506，必须打开端口才能接收到访问连接 Publisher （端口4505）所有Salt minions都需要建立一个持续连接到他们收听消息的发布者端口。命令是通过此端口异步发送给所有连接，这使命令可以在大量系统上同时执行。 Request Server （端口4506）Salt minios根据需要连接到请求服务器，将结果发送给Salt master，并安全地获取请求的文件或特定minion相关的数据值（称为Salt pillar）。连接到这个端口的连接在Salt master和Salt minion之间是1:1（不是异步）。 123456[root@salt-master ~]# lsof -i:4505COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsalt-mast 81121 root 16u IPv4 304019 0t0 TCP *:4505 (LISTEN)salt-mast 81121 root 18u IPv4 304082 0t0 TCP salt-master:4505-&gt;salt-minion03:37240 (ESTABLISHED)salt-mast 81121 root 19u IPv4 307610 0t0 TCP salt-master:4505-&gt;salt-minion01:47804 (ESTABLISHED)salt-mast 81121 root 20u IPv4 307611 0t0 TCP salt-master:4505-&gt;salt-minion02:58594 (ESTABLISHED) 快速安装1.1 配置 yum 仓库1234567# 使用官方自带yum[root@salt-master ~]# yum install https://repo.saltstack.com/yum/redhat/salt-repo-latest.el7.noarch.rpm# 或者使用阿里云的yum（建议使用阿里云的，速度快一点）[root@salt-master ~]# yum -y install https://mirrors.aliyun.com/saltstack/yum/redhat/salt-repo-latest-2.el7.noarch.rpm[root@salt-master ~]# sed -i "s/repo.saltstack.com/mirrors.aliyun.com\/saltstack/g" /etc/yum.repos.d/salt-latest.repo[root@salt-master ~]# yum clean all[root@salt-master ~]# yum makecache 1.2 安装Master，并启动服务123[root@salt-master ~]# yum -y install salt-master[root@salt-master ~]# systemctl enable salt-master[root@salt-master ~]# systemctl start salt-master 1.3 安装 Salt-Minion 指向 Salt-Master 网络地址123456[root@salt-minion01 ~]# yum -y install salt-minion# 可以使用主机名，也可以使用IP地址[root@salt-minion01 ~]# cp /etc/salt/minion&#123;,.back&#125;[root@salt-minion01 ~]# sed -i '/#master: /c\master: salt-master' /etc/salt/minion[root@salt-minion01 ~]# systemctl enable salt-minion[root@salt-minion01 ~]# systemctl start salt-minion SaltStack认证方式 Salt 的数据传输是通过 AES 加密，Master 和 Minion 之前在通信之前，需要进行认证。Salt 通过认证的方式保证安全性，完成一次认证后，Master 就可以控制 Minion 来完成各项工作了。1. minion 在第一次启动时候，会在 /etc/salt/pki/minion/ 下自动生成 minion.pem(private key) 和 minion.pub(public key), 然后将 minion.pub 发送给 master2. master 在第一次启动时，会在 /etc/salt/pki/master/ 下自动生成 master.pem 和 master.pub ；并且会接收到 minion 的 public key , 通过 salt-key 命令接收 minion public key， 会在 master 的 /etc/salt/pki/master/minions 目录下存放以 minion id 命令的 public key ；验证成功后同时 minion 会保存一份 master public key 在 minion的 /etc/salt/pki/minion/minion_master.pub里。 Salt认证原理总结 minion将自己的公钥发送给mastermaster认证后再将自己的公钥也发送给minion端 Master端认证示例根据上面提到的认证原理，先看下未认证前的master和minion的pki目录123456789101112131415161718192021# master上查看[root@salt-master ~]# tree /etc/salt/pki//etc/salt/pki/├── master│ ├── master.pem│ ├── master.pub│ ├── minions│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ │ └── salt-minion01│ └── minions_rejected└── minion# minion上查看[root@salt-minion01 ~]# tree /etc/salt/pki//etc/salt/pki/├── master└── minion ├── minion.pem └── minion.pub salt-key命令解释：12345678910111213141516[root@salt-master ~]# salt-key -L Accepted Keys: #已经接受的keyDenied Keys: #拒绝的keyUnaccepted Keys: #未加入的keyRejected Keys: #吊销的key#常用参数-L #查看KEY状态-A #允许所有-D #删除所有-a #认证指定的key-d #删除指定的key-r #注销掉指定key（该状态为未被认证）#配置master自动接受请求认证(master上配置 /etc/salt/master)auto_accept: True salt-key认证1234567891011121314151617181920212223#列出当前所有的key[root@salt-master ~]# salt-key -L Accepted Keys:Denied Keys:Unaccepted Keys:salt-minion01Rejected Keys:#添加指定minion的key[root@salt-master ~]# salt-key -a salt-minion01 -yThe following keys are going to be accepted:Unaccepted Keys:salt-minion01Key for minion salt-minion01 accepted.#添加所有minion的key[root@salt-master ~]# salt-key -A -y[root@salt-master ~]# salt-key -L Accepted Keys:salt-minion01Denied Keys:Unaccepted Keys:Rejected Keys: 上面认证完成后再次查看master和minion的pki目录12345678910111213141516171819202122# master上[root@salt-master ~]# tree /etc/salt/pki//etc/salt/pki/├── master│ ├── master.pem│ ├── master.pub│ ├── minions│ │ └── salt-minion01│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ └── minions_rejected└── minion# minion上[root@salt-minion01 ~]# tree /etc/salt/pki//etc/salt/pki/├── master└── minion ├── minion_master.pub ├── minion.pem └── minion.pub Saltstack远程执行 远程执行是 Saltstack 的核心功能之一。主要使用 salt 模块批量给选定的 minion 端执行相应的命令，并获得返回结果。 1、判断 salt 的 minion 主机是否存活1234567891011[root@salt-master ~]# salt '*' test.pingsalt-minion02: Truesalt-minion03: Truesalt-minion01: True# salt saltstack自带的一个命令# * 表示目标主机，这里表示所有目标主机# test.ping test是saltstack中的一个模块，ping则是这个模块下面的一个方法 2、saltstack使用 cmd.run模块远程执行shell命令1234#在指定目标minion节点运行uptime命令[root@salt-master ~]# salt 'salt-minion02' cmd.run 'uptime'salt-minion02: 18:13:08 up 28 min, 2 users, load average: 0.00, 0.04, 0.13 Saltstack配置管理Salt 通过State模块来进行文件的管理；通过YAML语法来描述，后缀是.sls的文件1、了解 YAML 参考：http://docs.saltstack.cn/topics/yaml/index.html123remove vim: pkg.removed: - name: vim 带有ID和每个函数调用的行都以冒号（:)结束。 每个函数调用在ID下面缩进两个空格。 参数作为列表传递给每个函数。 每行包含函数参数的行都以两个空格缩进开头，然后是连字符，然后是一个额外的空格。 如果参数采用单个值，则名称和值位于由冒号和空格分隔的同一行中。 如果一个参数需要一个列表，则列表从下一行开始，并缩进两个空格 2、配置sals ,定义环境 参考文档12345678910111213# 定义环境目录[root@salt-master ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt/base dev: - /srv/salt/dev prod: - /srv/salt/prod# 创建上面定义的目录[root@salt-master ~]# mkdir -p /srv/salt/&#123;base,dev,prod&#125;# 重启服务[root@salt-master ~]# systemctl restart salt-master 3、编写第一个sls文件1234567891011121314151617181920212223# 在base环境下编写第一个安装apache的sls文件[root@salt-master ~]# cd /srv/salt/base/[root@salt-master base]# cat apache.sls apache-install: pkg.installed: - name: httpdapache-service: service.running: - name: httpd - enable: True# 在dev环境下编写一个安装ftp的sls文件[root@salt-master base]# cd /srv/salt/dev/[root@salt-master dev]# cat vsftpd.sls vsftpd-install: pkg.installed: - name: vsftpdvsftpd-service: service.running: - name: vsftpd - enable: True 4、使用salt命令的state状态模块让minion应用配置12345# 让所有的minion都安装apache（由于salt默认的环境就是base，所以可以直接在后面指定调用的apache.sls文件，不要后缀sls）[root@salt-master ~]# salt '*' state.sls apache# 让所有的minion都安装vsftpd（saltenv指定环境）[root@salt-master ~]# salt '*' state.sls vsftpd saltenv=dev 5、使用salt的高级状态使不同主机应用不同的配置123456789101112# topfile入口文件只能放在base环境[root@salt-master ~]# cat /srv/salt/base/top.sls base: 'salt-minion01': - apache 'salt-minion03': - apachedev: 'salt-minion02': - vsftpd 'salt-minion03': - vsftpd 6、使用salt命令执行高级状态，会将top.sls当做入口文件，进行调用12# 将高级状态应用到所有主机[root@salt-master ~]# salt '*' state.highstate Saltstack常用配置1、Salt Master配置Salt Master端的配置文件/etc/salt/master，常用配置如下：123456789101112131415161718interface: //指定bind 的地址(默认为0.0.0.0)publish_port: //指定发布端口(默认为4505)ret_port: //指定结果返回端口, 与minion配置文件中的master_port对应(默认为4506)user: //指定master进程的运行用户,如果调整, 则需要调整部分目录的权限(默认为root)timeout: //指定timeout时间, 如果minion规模庞大或网络状况不好,建议增大该值(默认5s)keep_jobs: //minion执行结果返回master, master会缓存到本地的cachedir目录,该参数指定缓存多长时间,可查看之间执行结果会占用磁盘空间(默认为24h)job_cache: //master是否缓存执行结果,如果规模庞大(超过5000台),建议使用其他方式来存储jobs,关闭本选项(默认为True)file_recv : //是否允许minion传送文件到master 上(默认是Flase)file_roots: //指定file server目录, 默认为: file_roots: base: - /srv/salt pillar_roots : //指定pillar 目录, 默认为: pillar_roots: base: - /srv/pillar log_level: //日志级别支持的日志级别有'garbage', 'trace', 'debug', info', 'warning', 'error', ‘critical ’ ( 默认为’warning’) 2、Salt Minion端的配置文件/etc/salt/minion，常用配置如下：1234567891011master: //指定master 主机(默认为salt)master_port: //指定认证和执行结果发送到master的哪个端口, 与master配置文件中的ret_port对应(默认为4506)id: //指定本minion的标识, salt内部使用id作为标识(默认为主机名)user: //指定运行minion的用户.由于安装包,启动服务等操作需要特权用户, 推荐使用root( 默认为root)cache_jobs : //minion是否缓存执行结果(默认为False)backup_mode: //在文件操作(file.managed 或file.recurse) 时, 如果文件发送变更,指定备份目录.当前有效providers : //指定模块对应的providers, 如在RHEL系列中, pkg对应的providers 是yumpkg5renderer: //指定配置管理系统中的渲染器(默认值为:yaml_jinja )file_client : //指定file clinet 默认去哪里(remote 或local) 寻找文件(默认值为remote)loglevel: //指定日志级别(默认为warning)tcp_keepalive : //minion 是否与master 保持keepalive 检查, zeromq3(默认为True)]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下解压windows上压缩rar包]]></title>
    <url>%2F2019%2F04%2F30%2Flinux%E4%B8%8B%E8%A7%A3%E5%8E%8Bwindows%E4%B8%8A%E5%8E%8B%E7%BC%A9rar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[下载# wget http://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz 安装1234# tar xvzf rarlinux-3.8.0.tar.gz# cd rar# make # make install rar命令语法将 /etc 目录压缩为 etc.rar 命令为：\# rar a etc.rar /etc\将 etc.rar 解压 命令为：\12rar x etc.rarunrar -e etc.rar rar帮助手册123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# rarRAR 3.80 Copyright (c) 1993-2008 Alexander Roshal 16 Sep 2008Shareware version Type RAR -? for helpUsage: rar &lt;command&gt; -&lt;switch 1&gt; -&lt;switch N&gt; &lt;archive&gt; &lt;files...&gt; &lt;@listfiles...&gt; &lt;path_to_extract\&gt;&lt;Commands&gt; a Add files to archive c Add archive comment cf Add files comment ch Change archive parameters cw Write archive comment to file d Delete files from archive e Extract files to current directory f Freshen files in archive i[par]=&lt;str&gt; Find string in archives k Lock archive l[t,b] List archive [technical, bare] m[f] Move to archive [files only] p Print file to stdout r Repair archive rc Reconstruct missing volumes rn Rename archived files rr[N] Add data recovery record rv[N] Create recovery volumes s[name|-] Convert archive to or from SFX t Test archive files u Update files in archive v[t,b] Verbosely list archive [technical,bare] x Extract files with full path&lt;Switches&gt; - Stop switches scanning ad Append archive name to destination path ag[format] Generate archive name using the current date ap&lt;path&gt; Set path inside archive as Synchronize archive contents av Put authenticity verification (registered versions only) av- Disable authenticity verification check c- Disable comments show cfg- Disable read configuration cl Convert names to lower case cu Convert names to upper case df Delete files after archiving dh Open shared files ds Disable name sort for solid archive dw Wipe files after archiving e[+]&lt;attr&gt; Set file exclude and include attributes ed Do not add empty directories en Do not put 'end of archive' block ep Exclude paths from names ep1 Exclude base directory from names ep3 Expand paths to full including the drive letter f Freshen files hp[password] Encrypt both file data and headers id[c,d,p,q] Disable messages ierr Send all messages to stderr ilog[name] Log errors to file (registered versions only) inul Disable all messages isnd Enable sound k Lock archive kb Keep broken extracted files m&lt;0..5&gt; Set compression level (0-store...3-default...5-maximal) mc&lt;par&gt; Set advanced compression parameters md&lt;size&gt; Dictionary size in KB (64,128,256,512,1024,2048,4096 or A-G) ms[ext;ext] Specify file types to store n&lt;file&gt; Include only specified file n@ Read file names to include from stdin n@&lt;list&gt; Include files in specified list file o[+|-] Set the overwrite mode ol Save symbolic links as the link instead of the file or Rename files automatically ow Save or restore file owner and group p[password] Set password p- Do not query password r Recurse subdirectories r0 Recurse subdirectories for wildcard names only rr[N] Add data recovery record rv[N] Create recovery volumes s[&lt;N&gt;,v[-],e] Create solid archive s- Disable solid archiving sc&lt;chr&gt;[obj] Specify the character set sfx[name] Create SFX archive si[name] Read data from standard input (stdin) sl&lt;size&gt; Process files with size less than specified sm&lt;size&gt; Process files with size more than specified t Test files after archiving ta&lt;date&gt; Process files modified after &lt;date&gt; in YYYYMMDDHHMMSS format tb&lt;date&gt; Process files modified before &lt;date&gt; in YYYYMMDDHHMMSS format tk Keep original archive time tl Set archive time to latest file tn&lt;time&gt; Process files newer than &lt;time&gt; to&lt;time&gt; Process files older than &lt;time&gt; ts&lt;m,c,a&gt;[N] Save or restore file time (modification, creation, access) u Update files v Create volumes with size autodetection or list all volumes v&lt;size&gt;[k,b] Create volumes with size=&lt;size&gt;*1000 [*1024, *1] ver[n] File version control vn Use the old style volume naming scheme vp Pause before each volume w&lt;path&gt; Assign work directory x&lt;file&gt; Exclude specified file x@ Read file names to exclude from stdin x@&lt;list&gt; Exclude files in specified list file y Assume Yes on all queries z[file] Read archive comment from file]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpRedisAdmin搭建]]></title>
    <url>%2F2019%2F04%2F26%2FphpRedisAdmin%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在已有的lnmp 环境下搭建 phpRedisAdmin 由于服务器做了限制，隧道端口转发等都不能使用，导致 RedisDesktopManager 管理工具不能使用，只能通过 phpRedisAdmin来进行管理了。 1）下载软件123# git clone https://github.com/ErikDubbelboer/phpRedisAdmin.git# cd phpRedisAdmin# git clone https://github.com/nrk/predis.git vendor 2）放置到web站点目录123# cd ..# mv phpRedisAdmin /opt/# chown apache.apache phpRedisAdmin/ -R 3）编辑nginx配置文件1234567891011121314151617181920212223242526272829# vim phpRedisAdmin.confserver &#123; listen 80; server_name www.redis.com; autoindex off; error_log logs/redis_error.log error; access_log logs/redis_access.log main; location / &#123; root /opt/phpRedisAdmin; index index.php index.html index.htm; &#125; fastcgi_intercept_errors on; error_page 404 /404.html; location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /opt/phpRedisAdmin$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\. &#123; deny all; error_page 403 /404.html; &#125;&#125; 4）配置连接管理，默认连接的是6379端口123456789101112# vim /opt/phpRedisAdmin/includes/config.sample.inc.php$config = array( 'servers' =&gt; array( array( 'name' =&gt; 'local server', // Optional name. 'host' =&gt; '127.0.0.1', 'port' =&gt; 6395, 'filter' =&gt; '*', 'scheme' =&gt; 'tcp', // Optional. Connection scheme. 'tcp' - for TCP connection, 'unix' - for connection by unix domain socket 'path' =&gt; '', // Optional. Path to unix domain socket. Uses only if 'scheme' =&gt; 'unix'. Example: '/var/run/redis/redis.sock' 'auth' =&gt; 'jieg6uy5Dach0yooxo1l' // Warning: The password is sent in plain-text to the Redis server. ), 5）windows添加host然后访问 http://www.redis.com]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpMyAdmin搭建]]></title>
    <url>%2F2019%2F04%2F26%2FphpMyAdmin%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在已有的 lnmp 环境下搭建 phpMyAdmin。 由于服务器做了限制，隧道端口转发等都不能使用，导致 Navicat 管理工具不能使用，只能通过 phpMyAdmin 来进行管理了。 下载phpMyAdmin官网地址：https://www.phpmyadmin.net/ 上传到服务器进行安装 123# unzip phpMyAdmin-4.8.5-all-languages.zip# mv phpMyAdmin-4.8.5-all-languages /opt/phpMyAdmin# chown apache. /opt/phpMyAdmin 编辑配置文件 config.default.php 123456# vim /opt/phpMyAdmin/libraries/config.default.php$cfg['Servers'][$i]['host'] = '130.39.113.45';$cfg['Servers'][$i]['port'] = '3306';$cfg['Servers'][$i]['socket'] = 'socket';$cfg['Servers'][$i]['user'] = 'tj_court';$cfg['Servers'][$i]['password'] = 'AigheiguSh4eesh0eey8'; 配置nginx站点 1234567891011121314151617181920212223242526272829# vim phpMyAdmin.confserver &#123; listen 80; server_name www.phpadmin.com; autoindex off; error_log logs/phpadmin_error.log error; access_log logs/phpadmin_access.log main; location / &#123; root /opt/phpMyAdmin; index index.php index.html index.htm; &#125; fastcgi_intercept_errors on; error_page 404 /404.html; location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /opt/phpMyAdmin$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\. &#123; deny all; error_page 403 /404.html; &#125;&#125; 配置完成后启动nginx访问配置的域名进行连接]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自动备份脚本]]></title>
    <url>%2F2019%2F04%2F24%2FMySQL%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[通过 shell 脚本定时备份数据库，并定时清理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/bash#Desc:本地数据库备份脚本#Date:2017-12-24#by:Lee-YJ#运行脚本前先创建一个备份用户，并授予权限#mysql&gt; grant select,insert,lock tables,show view,trigger on *.* to back@"127.0.0.1" identified by "oodaeh7phoe1iboh7Jua";#mysql&gt; flush privileges;mysqluser=back #用于数据库备份的用户名mysqlpassw=oodaeh7phoe1iboh7Jua #用户密码mysqlhost=127.0.0.1 #连接数据库的hostbakpath=/opt/data/Back/DBbak #备份数据库存放的路径bakdate=`date '+%Y%m%d'`baktime=`date '+%H%M'`#----------------------------获取mysql中的数据库名---------------------------------/usr/bin/mysql -u$mysqluser -h $mysqlhost -p$mysqlpassw -e "show databases;"|grep -v Database|grep -v information_schema |grep -v performance_schema|grep -v mysql|grep -v test &gt; /tmp/DBname#----------------------------数据库备份--mysqldump备份------------------------------if [ ! -d "$bakpath" ];then mkdir -p $bakpathficd $bakpathif [ ! -d "$bakdate" ];then mkdir $bakdateficd $bakdateecho "------------------------$bakdate$baktime-------------------------------------" &gt;&gt; $bakpath/DBbak.logfor DBname in `cat /tmp/DBname`;do if [ ! -d "$DBname" ];then mkdir $DBname fi /usr/bin/mysqldump --routines --triggers -u$mysqluser -h $mysqlhost -p$mysqlpassw $DBname &gt; $DBname/$baktime\.sql if [ $? = 0 ];then echo "$DBname Back OK!" &gt;&gt; $bakpath/DBbak.log else echo "$DBname Back ERROR!" &gt;&gt; $bakpath/DBbak.log fidoneecho "" &gt;&gt; $bakpath/DBbak.log #----------------------------删除5天之前的数据备份，并随机保留一份--------------------------------shopt -s extglobolddate=`date '+%Y%m%d' -d "-6 days"`cd $bakpath/$olddatefor deldbname in `ls $bakpath/$olddate`;do cd $deldbname file=`ls| sort -R | head -n1` rm -f !($file)doneif [ ! -d "$bakpath/Oldest" ];then mkdir -p $bakpath/Oldestfimv $bakpath/$olddate $bakpath/Oldest/rm -f /tmp/DBname]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp虚拟用户]]></title>
    <url>%2F2019%2F04%2F23%2Fftp%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[需求：进（账户）\username: ftpComeSsbq\password: ftpcome#@UkieO9\上传文件的目录：/opt/ftp/come 出（账户）\username: ftpOutSsbq\password: ftpout#@45oUkie\上床文件的目录：/opt/ftp/out 具体步骤1 安装软件1# yum -y install vsftpd 2 创建相应的ftp数据目录1# mkdir -p /opt/ftp/&#123;come,out&#125; 3 创建一个用户提供给虚拟用户使用1# useradd -s /sbin/nologin virtual 4 将ftp数据目录设置成virtual用户12345# chown virtual. /opt/ftp/ -R# ll /opt/ftp/total 8drwxr-xr-x 2 virtual virtual 4096 Apr 17 12:07 comedrwxr-xr-x 2 virtual virtual 4096 Apr 17 12:07 out 5 创建虚拟帐号与密码的文本文件(一行账号，一行密码, 注意不要有多余的空格)12345# vim /etc/vsftpd/logins.txtftpComeSsbqftp_come_#@UkieO9ftpOutSsbqftp_out_#@45oUkie 6 将创建好的密码文件txt格式转换db格式1# db_load -T -t hash -f /etc/vsftpd/logins.txt /etc/vsftpd/login.db 7 定义db文件的权限1# chmod 600 /etc/vsftpd/login.db 8 定义pam认证文件123# vim /etc/pam.d/ftpauth required /lib64/security/pam_userdb.so db=/etc/vsftpd/loginaccount required /lib64/security/pam_userdb.so db=/etc/vsftpd/login 9 配置vsftpd主配置文件123456789101112131415161718192021222324252627282930313233343536# cp /etc/vsftpd/vsftpd.conf&#123;,.bak&#125;# vim /etc/vsftpd/vsftpd.conf#禁止匿名登录FTP服务器anonymous_enable=NO#允许本地用户登录FTP服务器local_enable=YES#可以上传(全局控制) write_enable=NO#匿名用户可以上传anon_upload_enable=NO#匿名用户可以建目录anon_mkdir_write_enable=NO#匿名用户修改删除anon_other_write_enable=NO#全部用户被限制在主目录chroot_local_user=YES#将所有用户看成虚拟用户guestguest_enable=YES#指定虚拟用户，也就是将guest用户映射到virtual用户guest_username=virtual#指定为独立服务listen=YES#指定监听的端口listen_port=21#开启被动模式pasv_enable=YES#FTP服务器公网IPpasv_address=120.79.93.66#设置被动模式下，建立数据传输可使用port范围的最小值pasv_min_port=10000#设置被动模式下，建立数据传输可使用port范围的最大值pasv_max_port=10088#是否允许匿名用户下载全局可读的文件anon_world_readable_only=NO#指定虚拟用户配置文件的路径user_config_dir=/etc/vsftpd/user_conf 10 创建上面配置文件中指定的子配置文件目录 user_conf1# mkdir /etc/vsftpd/user_conf 11 定义 ftpComeSsbq 用户的配置文件1234567# vim /etc/vsftpd/user_conf/ftpComeSsbqwrite_enable=YESanon_world_readable_only=noanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YESlocal_root=/opt/ftp/come 12 定义 ftpOutSsbq 用户的配置文件1234567# vim /etc/vsftpd/user_conf/ftpOutSsbqwrite_enable=YESanon_world_readable_only=noanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YESlocal_root=/opt/ftp/out 13 启动vsftpd1# service vsftpd start 14 测试…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
</search>
