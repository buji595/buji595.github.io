<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[saltstack配置管理]]></title>
    <url>%2F2019%2F05%2F15%2Fsaltstack%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Saltstack状态模块 远程执行模块的执行是过程式，而状态是对minion的一种描述和定义，管理人员不需要关系部署任务如何完成的，只需要描述minion的状态描述。它的和兴是写sls(Salt State file)文件，sls文件默认格式为YAML格式，并默认使用jinja模板，jinja是根据django的模板语言发展而来的语言，简单并强大，支持for if等循环语句。salt state主要用来描述系统，服务，配置文件的状态，常常被称为配置管理。 12345678910mysql-install: #ID声明，必须唯一 pkg.installed: #state状态声明 - pkgs: #选项声明 - mariadb: #选项列表 - mariadb-server说明：一个ID只能出现一次一个ID下相同模块只能使用一次一个ID下不可以使用多个不同模块 模块帮助手册12345678#列出所有状态模块[root@salt-master ~]# salt '*' sys.list_modules#查看指定模块的所有方法[root@salt-master ~]# salt '*' sys.list_state_functions pkg#查看指定模块的使用方法[root@salt-master ~]# salt '*' sys.state_doc pkg#查看指定模块的指定方法的用法[root@salt-master ~]# salt '*' sys.state_doc pkg.installed pkg软件模块pkg模块官档pkg.installed 软件安装1234567php-install: pkg.installed: - pkgs: - php - php-mysql: "&gt;=5.4.16" #指定安装版本 - php-pdo - php-cli 指定安装最新版本的软件1234567php-install: pkg.latest: - pkgs: - php - php-mysql - php-pdo - php-cli file文件模块file模块官档file.managed 下发文件，确保文件存在1234567891011121314151617181920212223[root@salt-master ~]# mkdir /srv/salt/base/files[root@salt-master ~]# cp /etc/httpd/conf/httpd.conf /srv/salt/base/files/[root@salt-master ~]# cat /srv/salt/base/apache_conf.slsapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644说明：- name: 表示存放目的地址- source: 表示这个文件来自哪里（说明这个文件得提前准备）或者这样写，直接已目的地址命令ID，这样ID也表示目的地址[root@salt-master ~]# cat /srv/salt/base/apache_conf.sls/etc/httpd/conf/httpd.conf: file.managed: - source: salt://files/httpd.conf - user: root - group: root - mode: 644 1234567891011121314151617小示例：[root@salt-master ~]# cat /srv/salt/base/test.sls/tmp/passwd_back: file.managed: - source: salt://files/passwd - user: root - group: root - mode: 644[root@salt-master ~]# cp /etc/passwd /srv/salt/base/files/[root@salt-master ~]# salt '*' state.sls test[root@salt-master ~]# salt '*' cmd.run "ls -l /tmp/passwd_back"salt-minion03: -rw-r--r-- 1 root root 2098 May 15 16:21 /tmp/passwd_backsalt-minion02: -rw-r--r-- 1 root root 2098 May 15 16:21 /tmp/passwd_backsalt-minion01: -rw-r--r-- 1 root root 2098 May 15 16:21 /tmp/passwd_back file.directory 建立目录12345678910111213141516[root@salt-master ~]# cat /srv/salt/base/directory.sls/tmp/saltdir: file.directory: - user: root - group: root - mode: 755 - makedirs: True #如果上一级目录不存在自动创建；类似（mkdir -p）[root@salt-master ~]# salt '*' state.sls directory[root@salt-master ~]# salt '*' cmd.run "ls -d /tmp/saltdir"salt-minion03: /tmp/saltdirsalt-minion02: /tmp/saltdirsalt-minion01: /tmp/saltdir file.recurse 下发整个目录1234567891011[root@salt-master ~]# cat /srv/salt/base/httpd_conf_dir.slshttpd_conf_dir: file.recurse: - name: /etc/httpd/conf.d - source: salt://files/conf.d - file_mode: 600 #文件权限 - dir_mode: 755 #目录权限 - include_empty: True #同步空目录 - clean: True #使用后minion与master保持一致[root@salt-master ~]# rsync -avh /etc/httpd/conf.d /srv/salt/base/files/ file.symlink 建立软链接12345678910111213[root@salt-master ~]# cat /srv/salt/base/target_link.sls/etc/grub.cfg: file.symlink: - target: /etc/grub2.cfg[root@salt-master ~]# salt '*' state.sls target_link[root@salt-master ~]# salt '*' cmd.run "ls -l /etc/grub.cfg"salt-minion03: lrwxrwxrwx 1 root root 14 May 15 16:42 /etc/grub.cfg -&gt; /etc/grub2.cfgsalt-minion01: lrwxrwxrwx 1 root root 14 May 15 16:42 /etc/grub.cfg -&gt; /etc/grub2.cfgsalt-minion02: lrwxrwxrwx 1 root root 14 May 15 16:42 /etc/grub.cfg -&gt; /etc/grub2.cfg service服务模块service模块官档12345678910111213[root@salt-master ~]# cat /srv/salt/base/service_httpd.slshttpd: service.running: - name: httpd #服务名称 - enable: True #开机自启动 - reload: True #允许重载配置文件，不写则是restart或者这样写[root@salt-master ~]# cat /srv/salt/base/service_httpd.slshttpd: #即表示ID，又表示服务名 service.running: - enable: True - reload: True 高级状态模块 当我们想要不同的主机应用不同的配置，那么可以使用高级状态管理 top file来进行管理。可以通过正则，grain模块，或分组名，来进行匹配，再下一级是要执行的state文件 可以将我们的配置需求转换为YAML并在Top file文件中表示： Top file示例1234567891011base: '*': #通过正则去匹配所有minion - app.nginx webserver: #定义的分组名称 - match: nodegroup - app.cron 'os:centos': #通过grains模块匹配 - match: grains - nginx Top file 高级状态的执行1[root@salt-master ~]# salt '*' state.highstate LAMP架构案例说明：该案例在prod环境配置1）环境准备，定义file_roots环境12345678[root@salt-master ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt/base dev: - /srv/salt/dev prod: - /srv/salt/prod 2）创建对应环境目录12[root@salt-master ~]# mkdir -p /srv/salt/&#123;base,dev,prod&#125;[root@salt-master ~]# mkdir /srv/salt/prod/&#123;httpd,php,mysql,files&#125; 3）配置文件准备及测试文件准备12345[root@salt-master ~]# cp /etc/my.cnf /srv/salt/prod/files/[root@salt-master ~]# cp /etc/httpd/conf/httpd.conf /srv/salt/prod/files/[root@salt-master ~]# cp /etc/php.ini /srv/salt/prod/files/[root@salt-master ~]# echo "&lt;h1&gt;LAMP html&lt;/h1&gt;" &gt;&gt;/srv/salt/prod/files/index.html[root@salt-master ~]# echo "&lt;?php phpinfo(); ?&gt;" &gt;&gt; /srv/salt/prod/files/index.php 4）编写state sls状态文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#httpd[root@salt-master ~]# cat /srv/salt/prod/httpd/init.slsapache-install: pkg.installed: - pkgs: - httpd - httpd-toolsapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644apache-service: service.running: - name: httpd - enable: True#php[root@salt-master ~]# cat /srv/salt/prod/php/init.slsphp-install: pkg.installed: - pkgs: - php - php-mysql - php-pdo - php-cliphp-config: file.managed: - name: /etc/php.ini - source: salt://files/php.ini - user: root - group: root - mode: 644#mysql[root@salt-master ~]# cat /srv/salt/prod/mysql/init.slsmariadb-install: pkg.installed: - pkgs: - mariadb-server - mariadbmariadb-config: file.managed: - name: /etc/my.cnf - source: salt://files/my.cnf - user: root - group: root - mode: 644mariadb-service: service.running: - name: mariadb - enable: True#测试文件[root@salt-master ~]# cat /srv/salt/prod/testfile.sls/var/www/html/index.html: file.managed: - source: salt://files/index.html/var/www/html/index.php: file.managed: - source: salt://files/index.php 6）topfile文件编写1234567[root@salt-master ~]# cat /srv/salt/base/top.slsprod: 'salt-minion*': - httpd.init - php.init - mysql.init - testfile 7）部署LAMP整体state文件查看12345678910111213141516171819[root@salt-master ~]# tree /srv/salt//srv/salt/├── base│ └── top.sls├── dev└── prod ├── files │ ├── httpd.conf │ ├── index.html │ ├── index.php │ ├── my.cnf │ └── php.ini ├── httpd │ └── init.sls ├── mysql │ └── init.sls ├── php │ └── init.sls └── testfile.sls 8）执行topfile1[root@salt-master ~]# salt '*' state.highstate States状态依赖通过上面的lamp可以看出已经可以使用state模块来定义minion的状态了，但是如果一个主机涉及多个状态，并且状态之间相互关联，在执行顺序上有先后之分，那么必须引用requisites来进行控制 关系说明：1、require 我依赖某个状态，我依赖谁2、require_in 我被某个状态依赖，谁依赖我3、watch 我关注某个状态，当状态发生改变，进行restart或者reload操作4、watch_in 我被某个状态关注5、include 我引用谁 1）修改上面lamp状态间依赖关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#httpd[root@salt-master ~]# cat /srv/salt/prod/httpd/init.slsapache-install: pkg.installed: - pkgs: - httpd - httpd-toolsapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644 - require: - pkg: apache-install #表示上面apache-install执行成功，才能执行apache-configapache-service: service.running: - name: httpd - enable: True - require: - file: apache-config - watch: - file: apache-config#php[root@salt-master ~]# cat /srv/salt/prod/php/init.slsphp-install: pkg.installed: - pkgs: - php - php-mysql - php-pdo - php-cli - reqiure_in: - file: php-configphp-config: file.managed: - name: /etc/php.ini - source: salt://files/php.ini - user: root - group: root - mode: 644#mysql[root@salt-master ~]# cat /srv/salt/prod/mysql/init.slsmariadb-install: pkg.installed: - pkgs: - mariadb-server - mariadbmariadb-config: file.managed: - name: /etc/my.cnf - source: salt://files/my.cnf - user: root - group: root - mode: 644 - require: - pkg: mariadb-installmariadb-service: service.running: - name: mariadb - enable: True - reload: True - require: - file: mariadb-config - watch: - file: mariadb-config 2）修改引用关系后include1234567891011121314151617181920212223242526272829303132[root@salt-master ~]# tree /srv/salt//srv/salt/├── base│ └── top.sls├── dev└── prod ├── files │ ├── httpd.conf │ ├── index.html │ ├── index.php │ ├── my.cnf │ └── php.ini ├── httpd │ └── init.sls ├── lamp.sls ├── mysql │ └── init.sls ├── php │ └── init.sls └── testfile.sls[root@salt-master ~]# cat /srv/salt/prod/lamp.slsinclude: - httpd.init - php.init - mysql.init - testfile[root@salt-master ~]# cat /srv/salt/base/top.slsprod: 'salt-minion*': - lamp 3）编写SLS技巧 1、按照状态分类，如果单独使用，清晰明了2、按照服务分类，可以被其它SLS引用 Jinja模板使用 配置文件一般灵活多变，比如配置apache的IP地址或者端口PORT等，则可以动态传值。Jinja官档salt jinja官档 Jinja2 模板包含变量和表达式，变量用 &#123;&#123; … &#125;&#125; 包围，表达式用 &#123;&#37; … &#37;&#125; 包围。变量使用示例：123456789101112131415161718192021222324252627282930313233[root@salt-master ~]# cat /srv/salt/base/var.sls &#123;% set var= 'hello world!' %&#125;test_var: cmd.run: - name: echo "测试变量 &#123;&#123; var &#125;&#125;"[root@salt-master ~]# salt 'salt-minion01' state.sls varsalt-minion01:---------- ID: test_var Function: cmd.run Name: echo "测试变量 hello world!" Result: True Comment: Command "echo "测试变量 hello world!"" run Started: 14:50:58.302424 Duration: 12.358 ms Changes: ---------- pid: 22510 retcode: 0 stderr: stdout: 测试变量 hello world!Summary for salt-minion01------------Succeeded: 1 (changed=1)Failed: 0------------Total states run: 1Total run time: 12.358 ms jinja2 常用变量1、字符串类型12&#123;% set var = 'test' %&#125; #定义变量&#123;&#123; var &#125;&#125; #调用变量 2、列表类型12&#123;% set list = ['one', 'two', 'three'] %&#125;&#123;&#123; list[1] &#125;&#125; #获取变量的第一个值 3、字典类型12&#123;% set dict = &#123;'key1':'value1', 'key2':'value2'&#125; %&#125;&#123;&#123; dict['key1'] &#125;&#125; #获取'key1'的值 示例1：Saltstack使用jinja模块配置apache监听端口12345678910111213141516171819202122#1.告诉file状态模块，需要使用jinja - template: jinja#2.列出参数列表 - defaults: PORT: 8000#3.配置文件引用jinja模板&#123;&#123; PORT &#125;&#125;# 配置示例apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644 - template: jinja - defaults: PORT: 8000# 修改httpd.conf配置文件引用变量Listen &#123;&#123; PORT &#125;&#125; 示例2：使用grinas 方式进行赋值123456789101112131415#配置示例apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://files/httpd.conf - user: root - group: root - mode: 644 - template: jinja - defaults: PORT: 8000 IPADDR: &#123;&#123; grains['fqdn_ip4'][0] &#125;&#125;# 修改httpd.conf配置文件引用变量Listen &#123;&#123; IPADDR &#125;&#125;:&#123;&#123; PORT &#125;&#125; 示例3：通过jinja+grains根据系统不同安装apache123456789[root@salt-master ~]# cat /srv/salt/base/httpd.sls#根据grains获取的值判别系统后安装软件httpd-install: pkg.installed:&#123;% if grains['os'] == 'CentOS' %&#125; - name: httpd&#123;% elif grains['OS'] == 'Debin' %&#125; - name: apache2&#123;% endif %&#125;]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack远程执行]]></title>
    <url>%2F2019%2F05%2F14%2Fsaltstack%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[安装完Saltstack后可以立即执行shell命令，更新软件包并将文件同时分不到所有受管系统。所有回复都以一致的可配置格式返回。远程执行参考文档：http://docs.saltstack.cn/topics/tutorials/modules.html1234567[root@salt-master ~]# salt '*' cmd.run "uptime"salt-minion01: 15:23:08 up 1 day, 58 min, 2 users, load average: 0.00, 0.03, 0.08salt-minion02: 15:23:08 up 21:38, 2 users, load average: 0.00, 0.04, 0.10salt-minion03: 15:23:08 up 21:36, 2 users, load average: 0.00, 0.04, 0.10 Salt命令的结构语法1salt '&lt;target&gt;' &lt;function&gt; [arguments] 目标主机Target1、通配符匹配123456[root@salt-master ~]# salt '*' test.ping[root@salt-master ~]# salt 'salt-minion01' test.ping[root@salt-master ~]# salt '*01' test.ping[root@salt-master ~]# salt 'salt-minion0[1|2]' test.ping[root@salt-master ~]# salt 'salt-minion0[!1|2]' test.ping[root@salt-master ~]# salt 'salt-minion0?' test.ping 2、列表匹配1[root@salt-master ~]# salt -L 'salt-minion01,salt-minion02' test.ping 3、正则匹配12[root@salt-master ~]# salt -E '^salt' test.ping[root@salt-master ~]# salt -E '^salt.*2$' test.ping 4、IP匹配12[root@salt-master ~]# salt -S '192.168.1.32' test.ping[root@salt-master ~]# salt -S '192.168.1.0/24' test.ping 5、复合匹配1[root@salt-master ~]# salt -C 'G@os:CentOS and S@192.168.1.32' test.ping 6、分组匹配1234567[root@salt-master ~]# vim /etc/salt/masternodegroups: webserver: 'salt-minion01,salt-minion02' dbserver: 'salt-minion03[root@salt-master ~]# systemctl restart salt-master[root@salt-master ~]# salt -N 'webserver' test.ping[root@salt-master ~]# salt -N 'dbserver' test.ping 7、Grains匹配12[root@salt-master ~]# salt -G 'os:CentOS' test.ping[root@salt-master ~]# salt -G 'localhost:salt-minion02' test.ping 说明：上面这些匹配方式在top.sls文件中同样适用。 模块Module test模块多用于测试user模块用于用户管理cmd模块可以执行任意shell命令pkg模块用于软件包管理file模块多用于配置service模块用于服务管理 所有模块列表 test模块123模块名：test功能：用于测试[root@salt-master ~]# salt '*' test.ping user模块123参考：http://docs.saltstack.cn/ref/modules/all/salt.modules.useradd.html#module-salt.modules.useradd# salt '*' user.add name &lt;uid&gt; &lt;gid&gt; &lt;groups&gt; &lt;home&gt; &lt;shell&gt;[root@salt-master ~]# salt '*' user.add testuser cmd模块12345模块名：cmd功能：实现远程的命令行调用执行（默认具备root操作权限，使用时需评估风险）#查看所有minion内存和磁盘使用情况[root@salt-master ~]# salt '*' cmd.run "free -m"[root@salt-master ~]# salt '*' cmd.run "df -h" pkg模块1234567891011121314模块名：pkg功能：软件包状态管理，会根据操作系统不同，选择对应的安装方式（如CentOS系统默认使用yum，Debian系统默认使用apt-get）#安装[root@salt-master ~]# salt '*' pkg.install "vsftpd"#卸载[root@salt-master ~]# salt '*' pkg.remove "vsftpd"#安装最新版本[root@salt-master ~]# salt '*' pkg.latest_version "vsftpd"#更新软件包[root@salt-master ~]# salt '*' pkg.upgrade "vsftpd"#查看帮助手册[root@salt-master ~]# salt '*' pkg file模块1234567891011121314151617181920212223242526272829模块名：file功能：被控主机常见的文件操作，包括文件读写、权限、查找、校验#校验所有minion主机文件的加密信息，支持md5、sha1、sha224、shs256、sha384、sha512加密算法[root@salt-master ~]# salt '*' file.get_sum /etc/passwd md5#修改所有minion主机/etc/passwd文件的属组、用户权限、等价于chown root:root /etc/passwd[root@salt-master ~]# salt '*' file.chown /etc/passwd root root#获取所有minion主机/etc/passwd的stats信息[root@salt-master ~]# salt '*' file.stats /etc/passwd#获取所有minion主机/etc/passwd的权限mode,如755,644[root@salt-master ~]# salt '*' file.get_mode /etc/passwd#修改所有minion主机/etc/passwd的权限mode为0644[root@salt-master ~]# salt '*' file.set_mode /etc/passwd 0644#在所有minion主机创建/opt/test目录[root@salt-master ~]# salt '*' file.mkdir /opt/test#在所有minion主机穿件/tmp/test.conf文件[root@salt-master ~]# salt '*' file.touch /tmp/test.conf#将所有minion主机/tmp/test.conf文件追加内容'maxclient 100'[root@salt-master ~]# salt '*' file.append /tmp/test.conf 'maxclient 100'#删除所有minion主机的/tmp/test.conf文件[root@salt-master ~]# salt '*' file.remove /tmp/test.conf service模块12345678910111213模块名：service功能：被控主机程序包服务管理#开启（enable）禁用（disable）salt '*' service.enable &lt;service name&gt;salt '*' service.disabled &lt;service name&gt;#reload、restart、start、stop、status操作salt '*' service.reload &lt;service name&gt;salt '*' service.restart &lt;service name&gt;salt '*' service.start &lt;service name&gt;salt '*' service.stop &lt;service name&gt;salt '*' service.status &lt;service name&gt;]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[saltstack基本入门]]></title>
    <url>%2F2019%2F05%2F13%2Fsaltstack%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[saltstack介绍Salt，,一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯 主要功能远程执行配置管理Stalstack官方文档 Saltstack原理 Salt使用server-agent通信模型，服务端组件被称为Salt master，agent被称为Salt minionSalt master主要负责向Salt minions发送命令，然后聚合并显示这些命令的结果。一个Salt master可以管理多个minion系统Salt server与Salt minion通信的连接由Salt minion发起，这也意味着Salt minion上不需要打开任何传入端口（从而减少攻击）。Salt server使用端口4505和4506，必须打开端口才能接收到访问连接 Publisher （端口4505）所有Salt minions都需要建立一个持续连接到他们收听消息的发布者端口。命令是通过此端口异步发送给所有连接，这使命令可以在大量系统上同时执行。 Request Server （端口4506）Salt minios根据需要连接到请求服务器，将结果发送给Salt master，并安全地获取请求的文件或特定minion相关的数据值（称为Salt pillar）。连接到这个端口的连接在Salt master和Salt minion之间是1:1（不是异步）。 123456[root@salt-master ~]# lsof -i:4505COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsalt-mast 81121 root 16u IPv4 304019 0t0 TCP *:4505 (LISTEN)salt-mast 81121 root 18u IPv4 304082 0t0 TCP salt-master:4505-&gt;salt-minion03:37240 (ESTABLISHED)salt-mast 81121 root 19u IPv4 307610 0t0 TCP salt-master:4505-&gt;salt-minion01:47804 (ESTABLISHED)salt-mast 81121 root 20u IPv4 307611 0t0 TCP salt-master:4505-&gt;salt-minion02:58594 (ESTABLISHED) 快速安装1.1 配置 yum 仓库1234567# 使用官方自带yum[root@salt-master ~]# yum install https://repo.saltstack.com/yum/redhat/salt-repo-latest.el7.noarch.rpm# 或者使用阿里云的yum（建议使用阿里云的，速度快一点）[root@salt-master ~]# yum -y install https://mirrors.aliyun.com/saltstack/yum/redhat/salt-repo-latest-2.el7.noarch.rpm[root@salt-master ~]# sed -i "s/repo.saltstack.com/mirrors.aliyun.com\/saltstack/g" /etc/yum.repos.d/salt-latest.repo[root@salt-master ~]# yum clean all[root@salt-master ~]# yum makecache 1.2 安装Master，并启动服务123[root@salt-master ~]# yum -y install salt-master[root@salt-master ~]# systemctl enable salt-master[root@salt-master ~]# systemctl start salt-master 1.3 安装 Salt-Minion 指向 Salt-Master 网络地址123456[root@salt-minion01 ~]# yum -y install salt-minion# 可以使用主机名，也可以使用IP地址[root@salt-minion01 ~]# cp /etc/salt/minion&#123;,.back&#125;[root@salt-minion01 ~]# sed -i '/#master: /c\master: salt-master' /etc/salt/minion[root@salt-minion01 ~]# systemctl enable salt-minion[root@salt-minion01 ~]# systemctl start salt-minion SaltStack认证方式 Salt 的数据传输是通过 AES 加密，Master 和 Minion 之前在通信之前，需要进行认证。Salt 通过认证的方式保证安全性，完成一次认证后，Master 就可以控制 Minion 来完成各项工作了。1. minion 在第一次启动时候，会在 /etc/salt/pki/minion/ 下自动生成 minion.pem(private key) 和 minion.pub(public key), 然后将 minion.pub 发送给 master2. master 在第一次启动时，会在 /etc/salt/pki/master/ 下自动生成 master.pem 和 master.pub ；并且会接收到 minion 的 public key , 通过 salt-key 命令接收 minion public key， 会在 master 的 /etc/salt/pki/master/minions 目录下存放以 minion id 命令的 public key ；验证成功后同时 minion 会保存一份 master public key 在 minion的 /etc/salt/pki/minion/minion_master.pub里。 Salt认证原理总结 minion将自己的公钥发送给mastermaster认证后再将自己的公钥也发送给minion端 Master端认证示例根据上面提到的认证原理，先看下未认证前的master和minion的pki目录123456789101112131415161718192021# master上查看[root@salt-master ~]# tree /etc/salt/pki//etc/salt/pki/├── master│ ├── master.pem│ ├── master.pub│ ├── minions│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ │ └── salt-minion01│ └── minions_rejected└── minion# minion上查看[root@salt-minion01 ~]# tree /etc/salt/pki//etc/salt/pki/├── master└── minion ├── minion.pem └── minion.pub salt-key命令解释：12345678910111213141516[root@salt-master ~]# salt-key -L Accepted Keys: #已经接受的keyDenied Keys: #拒绝的keyUnaccepted Keys: #未加入的keyRejected Keys: #吊销的key#常用参数-L #查看KEY状态-A #允许所有-D #删除所有-a #认证指定的key-d #删除指定的key-r #注销掉指定key（该状态为未被认证）#配置master自动接受请求认证(master上配置 /etc/salt/master)auto_accept: True salt-key认证1234567891011121314151617181920212223#列出当前所有的key[root@salt-master ~]# salt-key -L Accepted Keys:Denied Keys:Unaccepted Keys:salt-minion01Rejected Keys:#添加指定minion的key[root@salt-master ~]# salt-key -a salt-minion01 -yThe following keys are going to be accepted:Unaccepted Keys:salt-minion01Key for minion salt-minion01 accepted.#添加所有minion的key[root@salt-master ~]# salt-key -A -y[root@salt-master ~]# salt-key -L Accepted Keys:salt-minion01Denied Keys:Unaccepted Keys:Rejected Keys: 上面认证完成后再次查看master和minion的pki目录12345678910111213141516171819202122# master上[root@salt-master ~]# tree /etc/salt/pki//etc/salt/pki/├── master│ ├── master.pem│ ├── master.pub│ ├── minions│ │ └── salt-minion01│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ └── minions_rejected└── minion# minion上[root@salt-minion01 ~]# tree /etc/salt/pki//etc/salt/pki/├── master└── minion ├── minion_master.pub ├── minion.pem └── minion.pub Saltstack远程执行 远程执行是 Saltstack 的核心功能之一。主要使用 salt 模块批量给选定的 minion 端执行相应的命令，并获得返回结果。 1、判断 salt 的 minion 主机是否存活1234567891011[root@salt-master ~]# salt '*' test.pingsalt-minion02: Truesalt-minion03: Truesalt-minion01: True# salt saltstack自带的一个命令# * 表示目标主机，这里表示所有目标主机# test.ping test是saltstack中的一个模块，ping则是这个模块下面的一个方法 2、saltstack使用 cmd.run模块远程执行shell命令1234#在指定目标minion节点运行uptime命令[root@salt-master ~]# salt 'salt-minion02' cmd.run 'uptime'salt-minion02: 18:13:08 up 28 min, 2 users, load average: 0.00, 0.04, 0.13 Saltstack配置管理Salt 通过State模块来进行文件的管理；通过YAML语法来描述，后缀是.sls的文件1、了解 YAML 参考：http://docs.saltstack.cn/topics/yaml/index.html123remove vim: pkg.removed: - name: vim 带有ID和每个函数调用的行都以冒号（:)结束。 每个函数调用在ID下面缩进两个空格。 参数作为列表传递给每个函数。 每行包含函数参数的行都以两个空格缩进开头，然后是连字符，然后是一个额外的空格。 如果参数采用单个值，则名称和值位于由冒号和空格分隔的同一行中。 如果一个参数需要一个列表，则列表从下一行开始，并缩进两个空格 2、配置sals ,定义环境 参考文档12345678910111213# 定义环境目录[root@salt-master ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt/base dev: - /srv/salt/dev prod: - /srv/salt/prod# 创建上面定义的目录[root@salt-master ~]# mkdir -p /srv/salt/&#123;base,dev,prod&#125;# 重启服务[root@salt-master ~]# systemctl restart salt-master 3、编写第一个sls文件1234567891011121314151617181920212223# 在base环境下编写第一个安装apache的sls文件[root@salt-master ~]# cd /srv/salt/base/[root@salt-master base]# cat apache.sls apache-install: pkg.installed: - name: httpdapache-service: service.running: - name: httpd - enable: True# 在dev环境下编写一个安装ftp的sls文件[root@salt-master base]# cd /srv/salt/dev/[root@salt-master dev]# cat vsftpd.sls vsftpd-install: pkg.installed: - name: vsftpdvsftpd-service: service.running: - name: vsftpd - enable: True 4、使用salt命令的state状态模块让minion应用配置12345# 让所有的minion都安装apache（由于salt默认的环境就是base，所以可以直接在后面指定调用的apache.sls文件，不要后缀sls）[root@salt-master ~]# salt '*' state.sls apache# 让所有的minion都安装vsftpd（saltenv指定环境）[root@salt-master ~]# salt '*' state.sls vsftpd saltenv=dev 5、使用salt的高级状态使不同主机应用不同的配置123456789101112# topfile入口文件只能放在base环境[root@salt-master ~]# cat /srv/salt/base/top.sls base: 'salt-minion01': - apache 'salt-minion03': - apachedev: 'salt-minion02': - vsftpd 'salt-minion03': - vsftpd 6、使用salt命令执行高级状态，会将top.sls当做入口文件，进行调用12# 将高级状态应用到所有主机[root@salt-master ~]# salt '*' state.highstate Saltstack常用配置1、Salt Master配置Salt Master端的配置文件/etc/salt/master，常用配置如下：123456789101112131415161718interface: //指定bind 的地址(默认为0.0.0.0)publish_port: //指定发布端口(默认为4505)ret_port: //指定结果返回端口, 与minion配置文件中的master_port对应(默认为4506)user: //指定master进程的运行用户,如果调整, 则需要调整部分目录的权限(默认为root)timeout: //指定timeout时间, 如果minion规模庞大或网络状况不好,建议增大该值(默认5s)keep_jobs: //minion执行结果返回master, master会缓存到本地的cachedir目录,该参数指定缓存多长时间,可查看之间执行结果会占用磁盘空间(默认为24h)job_cache: //master是否缓存执行结果,如果规模庞大(超过5000台),建议使用其他方式来存储jobs,关闭本选项(默认为True)file_recv : //是否允许minion传送文件到master 上(默认是Flase)file_roots: //指定file server目录, 默认为: file_roots: base: - /srv/salt pillar_roots : //指定pillar 目录, 默认为: pillar_roots: base: - /srv/pillar log_level: //日志级别支持的日志级别有'garbage', 'trace', 'debug', info', 'warning', 'error', ‘critical ’ ( 默认为’warning’) 2、Salt Minion端的配置文件/etc/salt/minion，常用配置如下：1234567891011master: //指定master 主机(默认为salt)master_port: //指定认证和执行结果发送到master的哪个端口, 与master配置文件中的ret_port对应(默认为4506)id: //指定本minion的标识, salt内部使用id作为标识(默认为主机名)user: //指定运行minion的用户.由于安装包,启动服务等操作需要特权用户, 推荐使用root( 默认为root)cache_jobs : //minion是否缓存执行结果(默认为False)backup_mode: //在文件操作(file.managed 或file.recurse) 时, 如果文件发送变更,指定备份目录.当前有效providers : //指定模块对应的providers, 如在RHEL系列中, pkg对应的providers 是yumpkg5renderer: //指定配置管理系统中的渲染器(默认值为:yaml_jinja )file_client : //指定file clinet 默认去哪里(remote 或local) 寻找文件(默认值为remote)loglevel: //指定日志级别(默认为warning)tcp_keepalive : //minion 是否与master 保持keepalive 检查, zeromq3(默认为True)]]></content>
      <categories>
        <category>Saltstack</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linuxTools(小工具集合)]]></title>
    <url>%2F2019%2F04%2F30%2FlinuxTools-%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Linux下常用的小工具集合（grep cut soft uniq tee paste tr diff wc du df)这是一个测试 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmacshangmiances rwarsdfsdfsdfsdfsdf问我的是会 macshangmiances f21331d96b6546d78eff355b4f327f7aff2af26c 1111111111111111111111111 222 111]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下解压windows上压缩rar包]]></title>
    <url>%2F2019%2F04%2F30%2Flinux%E4%B8%8B%E8%A7%A3%E5%8E%8Bwindows%E4%B8%8A%E5%8E%8B%E7%BC%A9rar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[下载# wget http://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz 安装1234# tar xvzf rarlinux-3.8.0.tar.gz# cd rar# make # make install rar命令语法将 /etc 目录压缩为 etc.rar 命令为：\# rar a etc.rar /etc\将 etc.rar 解压 命令为：\12rar x etc.rarunrar -e etc.rar rar帮助手册123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# rarRAR 3.80 Copyright (c) 1993-2008 Alexander Roshal 16 Sep 2008Shareware version Type RAR -? for helpUsage: rar &lt;command&gt; -&lt;switch 1&gt; -&lt;switch N&gt; &lt;archive&gt; &lt;files...&gt; &lt;@listfiles...&gt; &lt;path_to_extract\&gt;&lt;Commands&gt; a Add files to archive c Add archive comment cf Add files comment ch Change archive parameters cw Write archive comment to file d Delete files from archive e Extract files to current directory f Freshen files in archive i[par]=&lt;str&gt; Find string in archives k Lock archive l[t,b] List archive [technical, bare] m[f] Move to archive [files only] p Print file to stdout r Repair archive rc Reconstruct missing volumes rn Rename archived files rr[N] Add data recovery record rv[N] Create recovery volumes s[name|-] Convert archive to or from SFX t Test archive files u Update files in archive v[t,b] Verbosely list archive [technical,bare] x Extract files with full path&lt;Switches&gt; - Stop switches scanning ad Append archive name to destination path ag[format] Generate archive name using the current date ap&lt;path&gt; Set path inside archive as Synchronize archive contents av Put authenticity verification (registered versions only) av- Disable authenticity verification check c- Disable comments show cfg- Disable read configuration cl Convert names to lower case cu Convert names to upper case df Delete files after archiving dh Open shared files ds Disable name sort for solid archive dw Wipe files after archiving e[+]&lt;attr&gt; Set file exclude and include attributes ed Do not add empty directories en Do not put 'end of archive' block ep Exclude paths from names ep1 Exclude base directory from names ep3 Expand paths to full including the drive letter f Freshen files hp[password] Encrypt both file data and headers id[c,d,p,q] Disable messages ierr Send all messages to stderr ilog[name] Log errors to file (registered versions only) inul Disable all messages isnd Enable sound k Lock archive kb Keep broken extracted files m&lt;0..5&gt; Set compression level (0-store...3-default...5-maximal) mc&lt;par&gt; Set advanced compression parameters md&lt;size&gt; Dictionary size in KB (64,128,256,512,1024,2048,4096 or A-G) ms[ext;ext] Specify file types to store n&lt;file&gt; Include only specified file n@ Read file names to include from stdin n@&lt;list&gt; Include files in specified list file o[+|-] Set the overwrite mode ol Save symbolic links as the link instead of the file or Rename files automatically ow Save or restore file owner and group p[password] Set password p- Do not query password r Recurse subdirectories r0 Recurse subdirectories for wildcard names only rr[N] Add data recovery record rv[N] Create recovery volumes s[&lt;N&gt;,v[-],e] Create solid archive s- Disable solid archiving sc&lt;chr&gt;[obj] Specify the character set sfx[name] Create SFX archive si[name] Read data from standard input (stdin) sl&lt;size&gt; Process files with size less than specified sm&lt;size&gt; Process files with size more than specified t Test files after archiving ta&lt;date&gt; Process files modified after &lt;date&gt; in YYYYMMDDHHMMSS format tb&lt;date&gt; Process files modified before &lt;date&gt; in YYYYMMDDHHMMSS format tk Keep original archive time tl Set archive time to latest file tn&lt;time&gt; Process files newer than &lt;time&gt; to&lt;time&gt; Process files older than &lt;time&gt; ts&lt;m,c,a&gt;[N] Save or restore file time (modification, creation, access) u Update files v Create volumes with size autodetection or list all volumes v&lt;size&gt;[k,b] Create volumes with size=&lt;size&gt;*1000 [*1024, *1] ver[n] File version control vn Use the old style volume naming scheme vp Pause before each volume w&lt;path&gt; Assign work directory x&lt;file&gt; Exclude specified file x@ Read file names to exclude from stdin x@&lt;list&gt; Exclude files in specified list file y Assume Yes on all queries z[file] Read archive comment from file]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpMyAdmin搭建]]></title>
    <url>%2F2019%2F04%2F26%2FphpMyAdmin%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在已有的 lnmp 环境下搭建 phpMyAdmin。 由于服务器做了限制，隧道端口转发等都不能使用，导致 Navicat 管理工具不能使用，只能通过 phpMyAdmin 来进行管理了。 下载phpMyAdmin\官网地址：https://www.phpmyadmin.net/ 上传到服务器进行安装 123# unzip phpMyAdmin-4.8.5-all-languages.zip# mv phpMyAdmin-4.8.5-all-languages /opt/phpMyAdmin# chown apache. /opt/phpMyAdmin 编辑配置文件 config.default.php 123456# vim /opt/phpMyAdmin/libraries/config.default.php$cfg['Servers'][$i]['host'] = '130.39.113.45';$cfg['Servers'][$i]['port'] = '3306';$cfg['Servers'][$i]['socket'] = 'socket';$cfg['Servers'][$i]['user'] = 'tj_court';$cfg['Servers'][$i]['password'] = 'AigheiguSh4eesh0eey8'; 配置nginx站点 1234567891011121314151617181920212223242526272829# vim phpMyAdmin.confserver &#123; listen 80; server_name www.phpadmin.com; autoindex off; error_log logs/phpadmin_error.log error; access_log logs/phpadmin_access.log main; location / &#123; root /opt/phpMyAdmin; index index.php index.html index.htm; &#125; fastcgi_intercept_errors on; error_page 404 /404.html; location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /opt/phpMyAdmin$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\. &#123; deny all; error_page 403 /404.html; &#125;&#125; 配置完成后启动nginx访问配置的域名进行连接]]></content>
      <categories>
        <category>Linux运维日常</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自动备份脚本]]></title>
    <url>%2F2019%2F04%2F24%2FMySQL%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[通过 shell 脚本定时备份数据库，并定时清理ceshi yixia 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/bash#Desc:本地数据库备份脚本#Date:2017-12-24#by:Lee-YJ#运行脚本前先创建一个备份用户，并授予权限#mysql&gt; grant select,insert,lock tables,show view,trigger on *.* to back@"127.0.0.1" identified by "oodaeh7phoe1iboh7Jua";#mysql&gt; flush privileges;mysqluser=back #用于数据库备份的用户名mysqlpassw=oodaeh7phoe1iboh7Jua #用户密码mysqlhost=127.0.0.1 #连接数据库的hostbakpath=/opt/data/Back/DBbak #备份数据库存放的路径bakdate=`date '+%Y%m%d'`baktime=`date '+%H%M'`#----------------------------获取mysql中的数据库名---------------------------------/usr/bin/mysql -u$mysqluser -h $mysqlhost -p$mysqlpassw -e "show databases;"|grep -v Database|grep -v information_schema |grep -v performance_schema|grep -v mysql|grep -v test &gt; /tmp/DBname#----------------------------数据库备份--mysqldump备份------------------------------if [ ! -d "$bakpath" ];then mkdir -p $bakpathficd $bakpathif [ ! -d "$bakdate" ];then mkdir $bakdateficd $bakdateecho "------------------------$bakdate$baktime-------------------------------------" &gt;&gt; $bakpath/DBbak.logfor DBname in `cat /tmp/DBname`;do if [ ! -d "$DBname" ];then mkdir $DBname fi /usr/bin/mysqldump --routines --triggers -u$mysqluser -h $mysqlhost -p$mysqlpassw $DBname &gt; $DBname/$baktime\.sql if [ $? = 0 ];then echo "$DBname Back OK!" &gt;&gt; $bakpath/DBbak.log else echo "$DBname Back ERROR!" &gt;&gt; $bakpath/DBbak.log fidoneecho "" &gt;&gt; $bakpath/DBbak.log #----------------------------删除5天之前的数据备份，并随机保留一份--------------------------------shopt -s extglobolddate=`date '+%Y%m%d' -d "-6 days"`cd $bakpath/$olddatefor deldbname in `ls $bakpath/$olddate`;do cd $deldbname file=`ls| sort -R | head -n1` rm -f !($file)doneif [ ! -d "$bakpath/Oldest" ];then mkdir -p $bakpath/Oldestfimv $bakpath/$olddate $bakpath/Oldest/rm -f /tmp/DBname]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp虚拟用户]]></title>
    <url>%2F2019%2F04%2F23%2Fftp%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[需求：进（账户）\username: ftpComeSsbq\password: ftpcome#@UkieO9\上传文件的目录：/opt/ftp/come 出（账户）\username: ftpOutSsbq\password: ftpout#@45oUkie\上床文件的目录：/opt/ftp/out 具体步骤1 安装软件1# yum -y install vsftpd 2 创建相应的ftp数据目录1# mkdir -p /opt/ftp/&#123;come,out&#125; 3 创建一个用户提供给虚拟用户使用1# useradd -s /sbin/nologin virtual 4 将ftp数据目录设置成virtual用户12345# chown virtual. /opt/ftp/ -R# ll /opt/ftp/total 8drwxr-xr-x 2 virtual virtual 4096 Apr 17 12:07 comedrwxr-xr-x 2 virtual virtual 4096 Apr 17 12:07 out 5 创建虚拟帐号与密码的文本文件(一行账号，一行密码, 注意不要有多余的空格)12345# vim /etc/vsftpd/logins.txtftpComeSsbqftp_come_#@UkieO9ftpOutSsbqftp_out_#@45oUkie 6 将创建好的密码文件txt格式转换db格式1# db_load -T -t hash -f /etc/vsftpd/logins.txt /etc/vsftpd/login.db 7 定义db文件的权限1# chmod 600 /etc/vsftpd/login.db 8 定义pam认证文件123# vim /etc/pam.d/ftpauth required /lib64/security/pam_userdb.so db=/etc/vsftpd/loginaccount required /lib64/security/pam_userdb.so db=/etc/vsftpd/login 9 配置vsftpd主配置文件123456789101112131415161718192021222324252627282930313233343536# cp /etc/vsftpd/vsftpd.conf&#123;,.bak&#125;# vim /etc/vsftpd/vsftpd.conf#禁止匿名登录FTP服务器anonymous_enable=NO#允许本地用户登录FTP服务器local_enable=YES#可以上传(全局控制) write_enable=NO#匿名用户可以上传anon_upload_enable=NO#匿名用户可以建目录anon_mkdir_write_enable=NO#匿名用户修改删除anon_other_write_enable=NO#全部用户被限制在主目录chroot_local_user=YES#将所有用户看成虚拟用户guestguest_enable=YES#指定虚拟用户，也就是将guest用户映射到virtual用户guest_username=virtual#指定为独立服务listen=YES#指定监听的端口listen_port=21#开启被动模式pasv_enable=YES#FTP服务器公网IPpasv_address=120.79.93.66#设置被动模式下，建立数据传输可使用port范围的最小值pasv_min_port=10000#设置被动模式下，建立数据传输可使用port范围的最大值pasv_max_port=10088#是否允许匿名用户下载全局可读的文件anon_world_readable_only=NO#指定虚拟用户配置文件的路径user_config_dir=/etc/vsftpd/user_conf 10 创建上面配置文件中指定的子配置文件目录 user_conf1# mkdir /etc/vsftpd/user_conf 11 定义 ftpComeSsbq 用户的配置文件1234567# vim /etc/vsftpd/user_conf/ftpComeSsbqwrite_enable=YESanon_world_readable_only=noanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YESlocal_root=/opt/ftp/come 12 定义 ftpOutSsbq 用户的配置文件1234567# vim /etc/vsftpd/user_conf/ftpOutSsbqwrite_enable=YESanon_world_readable_only=noanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YESlocal_root=/opt/ftp/out 13 启动vsftpd1# service vsftpd start 14 测试…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux运维日常</tag>
      </tags>
  </entry>
</search>
